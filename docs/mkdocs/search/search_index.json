{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#automated-driving-open-research-adore","title":"Automated Driving Open Research (ADORe)","text":"<p>Eclipse ADORe is a modular software library and toolkit for decision making, planning, control and simulation of automated vehicles.  ADORe provides:</p> <ul> <li>Algorithms and data models applied in real automated driving system for motion planning and control</li> <li>Mechanisms for safe interaction with other CAVs, infrastructure, traffic management, interactions with human-driven vehicles, bicyclists, pedestrians</li> <li>Integration with typical tools and formats such as ROS, SUMO, CARLA, OpenDrive, Road2Simulation, ITS-G5 V2X (MAPEM, SPATEM, DENM, MCM, SREM)</li> </ul> <p>The ADORe library (libadore) is written in system-independent c++. For execution and application it is coupled with ROS (adore_if_ros). Building and execution occurs in docker containers. </p>"},{"location":"#overview","title":"Overview","text":"<p>An ADORe control system works in concert with a perception stack (not provided) to control an autonomous vehicle platform. Using V2X radio messages, a list of detected objects and ego vehicle position and velocity, the ADORe control system provides control inputs to a vehicle platform in order to steer it along a given high-definition roadmap to the desired goal location. </p>"},{"location":"#example-application","title":"Example application","text":"<p>The following video shows an automated vehicle controlled by ADORe in an urban setting in Braunschweig, Germany: </p>"},{"location":"#documentation","title":"Documentation","text":"<p>In order to get started, it is advised to first check system requirements, follow the installation instruction and then try out the demo scenarios. - System requirements - Installation and getting started - Executable ROS demo scenarios - Manual - How to contribute</p>"},{"location":"about_adore/","title":"Automated Driving Open Research (ADORe)","text":""},{"location":"about_adore/#about-adore","title":"About ADORe","text":"<p>Eclipse ADORe is a modular software library and toolkit for decision making,  planning, control and simulation of automated vehicles.   It developed by The German Aerospace Center (DLR),   Institute for Transportation Systems \ud83d\udd17. ADORe provides some of the following features and capabilities:</p> <ul> <li>Algorithms and data models applied in real automated driving system for motion   planning and control</li> <li>Mechanisms for safe interaction with other CAVs, infrastructure, traffic    management, interactions with human-driven vehicles, bicyclists, pedestrians</li> <li>Integration with typical tools and formats such as SUMO \ud83d\udd17,   CARLA, OpenDrive, Road2Simulation, ITS-G5 V2X (MAPEM, SPATEM, DENM, MCM, SREM)</li> <li>ADORe is ROS \ud83d\udd17 based</li> <li>ADORe is fully containerized using Docker \ud83d\udd17</li> <li>ADORe is currently deployed on DLR TS institute research vehicles FASCar \ud83d\udd17 and VIEWCar II\ud83d\udd17</li> </ul>"},{"location":"about_adore/#adore-in-action","title":"ADORe In Action","text":"<p>Here you can see one of our automated test vehicles being operated by ADORe: </p>"},{"location":"adore_status/","title":"ADORe CI Ecosystem Status Dashboard","text":"Repository Name URL Build Status adore https://github.com/exclipse/adore adore_cli https://github.com/DLR-TS/adore_cli adore_if_carla https://github.com/DLR-TS/adore_if_carla n/a adore_if_ros https://github.com/DLR-TS/adore_if_ros adore_if_ros_msg https://github.com/DLR-TS/adore_if_ros_msg adore_if_v2x https://github.com/DLR-TS/adore_if_v2x adore_scheduling https://github.com/DLR-TS/adore_scheduling adore_v2x_sim https://github.com/DLR-TS/adore_v2x_sim catkin_docker https://github.com/DLR-TS/catkin_docker coordinate_conversion https://github.com/DLR-TS/coordinate_conversion libadore https://github.com/dlr-ts/libadore plotlablib https://github.com/DLR-TS/plotlablib plotlabserver https://github.com/DLR-TS/plotlabserver sumo_if_ros https://github.com/DLR-TS/sumo_if_ros v2x_if_ros_msg https://github.com/DLR-TS/v2x_if_ros_msg"},{"location":"contact/","title":"Contact","text":""},{"location":"contact/#contact","title":"Contact","text":"<p>If you have questions, need support, or have other inquiries please reach out to us. We are proudly open source and are interested to discover how you are using ADORe or components of ADORe. We are eager to hear from you.</p> <p>Email: opensource-ts@dlr.de</p>"},{"location":"control_system/","title":"Control System","text":""},{"location":"control_system/#control-system","title":"Control system","text":"<p>This section will contain details on the ADORe control system used for decision  making, planning, control and simulation of automated vehicles.</p>"},{"location":"control_system/#table-of-contents","title":"Table of Contents","text":""},{"location":"control_system/#1-hd-map-and-navigation","title":"1. HD-Map and Navigation","text":""},{"location":"control_system/#2-environment-model","title":"2. Environment Model","text":""},{"location":"control_system/#3-trajectory-planning","title":"3. Trajectory Planning","text":""},{"location":"control_system/#4-decision-making","title":"4. Decision Making","text":""},{"location":"control_system/#5-stabilization","title":"5. Stabilization","text":""},{"location":"docstyle/","title":"Docstyle","text":""},{"location":"docstyle/#how-to-document-source-code","title":"How to document source code","text":"<ul> <li>use visual studio code doxygen plugin: Doxygen Documentation Generator</li> <li>use javadoc doxygen style</li> <li>priority 0: document every class</li> <li>priority 1: document public functions, brief</li> <li>priority 2: document function parameters</li> <li>priority 3: document member variables</li> </ul>"},{"location":"docstyle/#example-of-doxygen-javadoc-example-copied-from-doxygennl","title":"Example of Doxygen Javadoc Example, copied from doxygen.nl","text":"<pre><code>/**\n *  A test class. A more elaborate class description.\n */\n\nclass Javadoc_Test\n{\n  public:\n\n    /** \n     * An enum.\n     * More detailed enum description.\n     */\n\n    enum TEnum { \n          TVal1, /**&lt; enum value TVal1. */  \n          TVal2, /**&lt; enum value TVal2. */  \n          TVal3  /**&lt; enum value TVal3. */  \n         } \n       *enumPtr, /**&lt; enum pointer. Details. */\n       enumVar;  /**&lt; enum variable. Details. */\n\n      /**\n       * A constructor.\n       * A more elaborate description of the constructor.\n       */\n      Javadoc_Test();\n\n      /**\n       * A destructor.\n       * A more elaborate description of the destructor.\n       */\n     ~Javadoc_Test();\n\n      /**\n       * a normal member taking two arguments and returning an integer value.\n       * @param a an integer argument.\n       * @param s a constant character pointer.\n       * @see Javadoc_Test()\n       * @see ~Javadoc_Test()\n       * @see testMeToo()\n       * @see publicVar()\n       * @return The test results\n       */\n       int testMe(int a,const char *s);\n\n      /**\n       * A pure virtual member.\n       * @see testMe()\n       * @param c1 the first argument.\n       * @param c2 the second argument.\n       */\n       virtual void testMeToo(char c1,char c2) = 0;\n\n      /** \n       * a public variable.\n       * Details.\n       */\n       int publicVar;\n\n      /**\n       * a function variable.\n       * Details.\n       */\n       int (*handler)(int a,int b);\n};\n</code></pre>"},{"location":"document_admonition_templates/","title":"Document admonition templates","text":"<p>\u26a0\ufe0f WARNING: Doh this ain't good.</p> <p>\u274cERROR: BAD BAD BAD ERROR</p> <p>\u2139\ufe0fINFO: Some info.</p> <p>\u2705SUCCESS: Some good thing.</p>"},{"location":"getting_help/","title":"Getting Help","text":""},{"location":"getting_help/#getting-help","title":"Getting Help","text":"<p>Have you encountered a problem that is not documented? Create an issue</p> <p>Send us an email: opensource-ts@dlr.de</p> <p>We are eager to help you don't hesitate to reach out.</p>"},{"location":"interfaces/","title":"Interfaces","text":""},{"location":"interfaces/#interfaces","title":"Interfaces","text":"<p>This section describes all software interfaces of ADORe.</p>"},{"location":"interfaces/#table-of-contents","title":"Table of Contents","text":""},{"location":"interfaces/#1-ros","title":"1. ROS","text":""},{"location":"interfaces/#2-perception","title":"2. Perception","text":""},{"location":"interfaces/#3-vehicle-platform","title":"3. Vehicle Platform","text":""},{"location":"interfaces/#4-v2x-messages","title":"4. V2X Messages","text":""},{"location":"interfaces/#5-sumo","title":"5. SUMO","text":""},{"location":"interfaces/#6-carla","title":"6. CARLA","text":""},{"location":"licensing/","title":"Licensing","text":"<p>Unless otherwise stated by another license all ADORe components, libraries, submodules, and project are under the  Eclipse Public License - v 2.0  </p>"},{"location":"modules/","title":"Module Quick Reference","text":""},{"location":"modules/#module-quick-reference","title":"Module Quick Reference","text":"<p>This section contains an aggregation of all README.md files for every submoduled within ADORe.</p> <p>\u26a0\ufe0f WARNING: The following README.md aggregation could be outdated and likely to have many broken links. This is intended to only be a quick reference. Please always  follow the individual submodules URLs for the most up-to-date documentation. </p>"},{"location":"modules/#module-adore_cli","title":"Module: adore_cli","text":"<p>git remote: git@github.com:DLR-TS/adore_cli.git</p> <p>url: https://github.com/DLR-TS/adore_cli \ud83d\udd17</p>"},{"location":"modules/#adore_cli-readme-links","title":"adore_cli README Links","text":"<p>adore_cli/README.md \ud83d\udd17</p>"},{"location":"modules/#module-adore_if_carla","title":"Module: adore_if_carla","text":"<p>git remote: git@github.com:dlr-ts/adore_if_carla</p> <p>url: https://github.com/dlr-ts/adore_if_carla \ud83d\udd17</p>"},{"location":"modules/#adore_if_carla-readme-links","title":"adore_if_carla README Links","text":"<p>adore_if_carla/adore_if_carla/README.md \ud83d\udd17</p> <p>adore_if_carla/README.md \ud83d\udd17</p>"},{"location":"modules/#module-adore_if_ros","title":"Module: adore_if_ros","text":"<p>git remote: git@github.com:DLR-TS/adore_if_ros.git</p> <p>url: https://github.com/DLR-TS/adore_if_ros \ud83d\udd17</p>"},{"location":"modules/#adore_if_ros-readme-links","title":"adore_if_ros README Links","text":"<p>adore_if_ros/adore_if_ros/README.md \ud83d\udd17</p>"},{"location":"modules/#module-adore_if_ros_msg","title":"Module: adore_if_ros_msg","text":"<p>git remote: git@github.com:dlr-ts/adore_if_ros_msg</p> <p>url: https://github.com/dlr-ts/adore_if_ros_msg \ud83d\udd17</p>"},{"location":"modules/#adore_if_ros_msg-readme-links","title":"adore_if_ros_msg README Links","text":"<p>adore_if_ros_msg/adore_if_ros_msg/README.md \ud83d\udd17</p> <p>adore_if_ros_msg/README.md \ud83d\udd17</p>"},{"location":"modules/#module-adore_if_ros_1","title":"Module: adore_if_ros","text":"<p>git remote: git@github.com:DLR-TS/adore_if_ros.git</p> <p>url: https://github.com/DLR-TS/adore_if_ros \ud83d\udd17</p>"},{"location":"modules/#adore_if_ros-readme-links_1","title":"adore_if_ros README Links","text":"<p>adore_if_ros/README.md \ud83d\udd17</p>"},{"location":"modules/#module-adore_if_v2x","title":"Module: adore_if_v2x","text":"<p>git remote: git@github.com:dlr-ts/adore_if_v2x</p> <p>url: https://github.com/dlr-ts/adore_if_v2x \ud83d\udd17</p>"},{"location":"modules/#adore_if_v2x-readme-links","title":"adore_if_v2x README Links","text":"<p>adore_if_v2x/adore_if_v2x/README.md \ud83d\udd17</p> <p>adore_if_v2x/README.md \ud83d\udd17</p>"},{"location":"modules/#module-adore_scenarios","title":"Module: adore_scenarios","text":"<p>git remote: git@github.com:DLR-TS/adore_scenarios.git</p> <p>url: https://github.com/DLR-TS/adore_scenarios \ud83d\udd17</p>"},{"location":"modules/#adore_scenarios-readme-links","title":"adore_scenarios README Links","text":"<p>adore_scenarios/README.md \ud83d\udd17</p>"},{"location":"modules/#module-adore_scheduling","title":"Module: adore_scheduling","text":"<p>git remote: git@github.com:DLR-TS/adore_scheduling.git</p> <p>url: https://github.com/DLR-TS/adore_scheduling \ud83d\udd17</p>"},{"location":"modules/#adore_scheduling-readme-links","title":"adore_scheduling README Links","text":"<p>adore_scheduling/adore_if_ros_scheduling/adore_if_ros_scheduling/README.md \ud83d\udd17</p> <p>adore_scheduling/adore_if_ros_scheduling_msg/adore_if_ros_scheduling_msg/README.md \ud83d\udd17</p> <p>adore_scheduling/adore_if_ros_scheduling_msg/README.md \ud83d\udd17</p> <p>adore_scheduling/adore_if_ros_scheduling/README.md \ud83d\udd17</p> <p>adore_scheduling/adore_scheduler/adore_scheduler/README.md \ud83d\udd17</p> <p>adore_scheduling/adore_scheduler/README.md \ud83d\udd17</p> <p>adore_scheduling/lib_adore_scheduling/lib_adore_scheduling/README.md \ud83d\udd17</p> <p>adore_scheduling/lib_adore_scheduling/README.md \ud83d\udd17</p> <p>adore_scheduling/README.md \ud83d\udd17</p>"},{"location":"modules/#module-adore_tools","title":"Module: adore_tools","text":"<p>git remote: git@github.com:DLR-TS/adore_tools.git</p> <p>url: https://github.com/DLR-TS/adore_tools \ud83d\udd17</p>"},{"location":"modules/#adore_tools-readme-links","title":"adore_tools README Links","text":"<p>adore_tools/README.md \ud83d\udd17</p> <p>adore_tools/tools/README.md \ud83d\udd17</p> <p>adore_tools/vagrant/README.md \ud83d\udd17</p>"},{"location":"modules/#module-adore_v2x_sim","title":"Module: adore_v2x_sim","text":"<p>git remote: git@github.com:dlr-ts/adore_v2x_sim</p> <p>url: https://github.com/dlr-ts/adore_v2x_sim \ud83d\udd17</p>"},{"location":"modules/#adore_v2x_sim-readme-links","title":"adore_v2x_sim README Links","text":"<p>adore_v2x_sim/adore_v2x_sim/README.md \ud83d\udd17</p> <p>adore_v2x_sim/README.md \ud83d\udd17</p>"},{"location":"modules/#module-apt_cacher_ng_docker","title":"Module: apt_cacher_ng_docker","text":"<p>git remote: git@github.com:DLR-TS/apt_cacher_ng_docker.git</p> <p>url: https://github.com/DLR-TS/apt_cacher_ng_docker \ud83d\udd17</p>"},{"location":"modules/#apt_cacher_ng_docker-readme-links","title":"apt_cacher_ng_docker README Links","text":"<p>apt_cacher_ng_docker/README.md \ud83d\udd17</p>"},{"location":"modules/#module-catkin_docker","title":"Module: catkin_docker","text":"<p>git remote: git@github.com:DLR-TS/catkin_docker.git</p> <p>url: https://github.com/DLR-TS/catkin_docker \ud83d\udd17</p>"},{"location":"modules/#catkin_docker-readme-links","title":"catkin_docker README Links","text":"<p>catkin_docker/README.md \ud83d\udd17</p>"},{"location":"modules/#module-ci_teststand","title":"Module: ci_teststand","text":"<p>git remote: git@github.com:DLR-TS/ci_teststand.git</p> <p>url: https://github.com/DLR-TS/ci_teststand \ud83d\udd17</p>"},{"location":"modules/#ci_teststand-readme-links","title":"ci_teststand README Links","text":"<p>ci_teststand/README.md \ud83d\udd17</p>"},{"location":"modules/#module-coordinate_conversion","title":"Module: coordinate_conversion","text":"<p>git remote: git@github.com:DLR-TS/coordinate_conversion.git</p> <p>url: https://github.com/DLR-TS/coordinate_conversion \ud83d\udd17</p>"},{"location":"modules/#coordinate_conversion-readme-links","title":"coordinate_conversion README Links","text":"<p>coordinate_conversion/README.md \ud83d\udd17</p>"},{"location":"modules/#module-cppcheck_docker","title":"Module: cppcheck_docker","text":"<p>git remote: git@github.com:DLR-TS/cppcheck_docker.git</p> <p>url: https://github.com/DLR-TS/cppcheck_docker \ud83d\udd17</p>"},{"location":"modules/#cppcheck_docker-readme-links","title":"cppcheck_docker README Links","text":"<p>cppcheck_docker/README.md \ud83d\udd17</p>"},{"location":"modules/#module-cpplint_docker","title":"Module: cpplint_docker","text":"<p>git remote: git@github.com:DLR-TS/cpplint_docker.git</p> <p>url: https://github.com/DLR-TS/cpplint_docker \ud83d\udd17</p>"},{"location":"modules/#cpplint_docker-readme-links","title":"cpplint_docker README Links","text":"<p>cpplint_docker/README.md \ud83d\udd17</p>"},{"location":"modules/#module-libadore","title":"Module: libadore","text":"<p>git remote: git@github.com:DLR-TS/libadore.git</p> <p>url: https://github.com/DLR-TS/libadore \ud83d\udd17</p>"},{"location":"modules/#libadore-readme-links","title":"libadore README Links","text":"<p>libadore/libadore/adore/apps/README.md \ud83d\udd17</p> <p>libadore/libadore/adore/env/README.md \ud83d\udd17</p> <p>libadore/libadore/adore/fun/README.md \ud83d\udd17</p> <p>libadore/libadore/adore/if_r2s/README.md \ud83d\udd17</p> <p>libadore/libadore/adore/if_xodr/README.md \ud83d\udd17</p> <p>libadore/libadore/adore/mad/README.md \ud83d\udd17</p> <p>libadore/libadore/adore/params/README.md \ud83d\udd17</p> <p>libadore/libadore/adore/sim/README.md \ud83d\udd17</p> <p>libadore/libadore/external/README.md \ud83d\udd17</p> <p>libadore/libadore/README.md \ud83d\udd17</p> <p>libadore/README.md \ud83d\udd17</p>"},{"location":"modules/#module-lizard_docker","title":"Module: lizard_docker","text":"<p>git remote: git@github.com:DLR-TS/lizard_docker.git</p> <p>url: https://github.com/DLR-TS/lizard_docker \ud83d\udd17</p>"},{"location":"modules/#lizard_docker-readme-links","title":"lizard_docker README Links","text":"<p>lizard_docker/README.md \ud83d\udd17</p>"},{"location":"modules/#module-make_gadgets","title":"Module: make_gadgets","text":"<p>git remote: git@github.com:DLR-TS/make_gadgets.git</p> <p>url: https://github.com/DLR-TS/make_gadgets \ud83d\udd17</p>"},{"location":"modules/#make_gadgets-readme-links","title":"make_gadgets README Links","text":"<p>make_gadgets/docker/README.md \ud83d\udd17</p> <p>make_gadgets/README.md \ud83d\udd17</p>"},{"location":"modules/#module-plotlablib","title":"Module: plotlablib","text":"<p>git remote: git@github.com:DLR-TS/plotlablib.git</p> <p>url: https://github.com/DLR-TS/plotlablib \ud83d\udd17</p>"},{"location":"modules/#plotlablib-readme-links","title":"plotlablib README Links","text":"<p>plotlablib/plotlablib/README.md \ud83d\udd17</p> <p>plotlablib/README.md \ud83d\udd17</p>"},{"location":"modules/#module-plotlabserver","title":"Module: plotlabserver","text":"<p>git remote: git@github.com:dlr-ts/plotlabserver</p> <p>url: https://github.com/dlr-ts/plotlabserver \ud83d\udd17</p>"},{"location":"modules/#plotlabserver-readme-links","title":"plotlabserver README Links","text":"<p>plotlabserver/plotlabserver/README.md \ud83d\udd17</p> <p>plotlabserver/README.md \ud83d\udd17</p>"},{"location":"modules/#module-adore","title":"Module: adore","text":"<p>git remote: git@github.com:eclipse/adore</p> <p>url: https://github.com/eclipse/adore \ud83d\udd17</p>"},{"location":"modules/#adore-readme-links","title":"adore README Links","text":"<p>adore/README.md \ud83d\udd17</p>"},{"location":"modules/#module-sumo_if_ros","title":"Module: sumo_if_ros","text":"<p>git remote: git@github.com:dlr-ts/sumo_if_ros</p> <p>url: https://github.com/dlr-ts/sumo_if_ros \ud83d\udd17</p>"},{"location":"modules/#sumo_if_ros-readme-links","title":"sumo_if_ros README Links","text":"<p>sumo_if_ros/README.md \ud83d\udd17</p> <p>sumo_if_ros/sumo_if_ros/README.md \ud83d\udd17</p>"},{"location":"modules/#module-v2x_if_ros_msg","title":"Module: v2x_if_ros_msg","text":"<p>git remote: git@github.com:dlr-ts/v2x_if_ros_msg</p> <p>url: https://github.com/dlr-ts/v2x_if_ros_msg \ud83d\udd17</p>"},{"location":"modules/#v2x_if_ros_msg-readme-links","title":"v2x_if_ros_msg README Links","text":"<p>v2x_if_ros_msg/README.md \ud83d\udd17</p> <p>v2x_if_ros_msg/v2x_if_ros_msg/cam_v2/README.md \ud83d\udd17</p> <p>v2x_if_ros_msg/v2x_if_ros_msg/denm_v2/README.md \ud83d\udd17</p> <p>v2x_if_ros_msg/v2x_if_ros_msg/dsrc_v2/README.md \ud83d\udd17</p> <p>v2x_if_ros_msg/v2x_if_ros_msg/its_container_v2/README.md \ud83d\udd17</p> <p>v2x_if_ros_msg/v2x_if_ros_msg/README.md \ud83d\udd17</p>"},{"location":"problems_and_solutions/","title":"Problems and Solutions","text":"<p>This section will offer solutions to known issues.</p>"},{"location":"problems_and_solutions/#problem-during-roslaunch-some-node-cannot-be-found","title":"Problem: During roslaunch some node cannot be found","text":"<p>You run a scenario and roslaunch reports that some node cannot be found. Not all nodes are built by default on invocation of <code>make cli</code> resulting in some nodes not being availabe. In this situation you could see an output similar  to the following:</p> <pre><code>...\nprocess[vehicle0/tlplotter-17]: started with pid [373]\nERROR: cannot launch node of type [adore_v2x_sim/channel_sim_node]: Cannot locate node of type [channel_sim_node] in package [\nadore_v2x_sim]. Make sure file exists in package path and permission is set to executable (chmod +x)                          \nERROR: cannot launch node of type [adore_if_v2x/v2x_trafficlights_node]: Cannot locate node of type [v2x_trafficlights_node] i\nn package [adore_if_v2x]. Make sure file exists in package path and permission is set to executable (chmod +x) \n...\n</code></pre>"},{"location":"problems_and_solutions/#solution-during-roslaunch-some-node-cannot-be-found","title":"Solution: During roslaunch some node cannot be found","text":"<p>This likely means the node you are trying to use has not been built.</p> <p>The fix for this is to deliberately build the node you are interested in. In the  previous example the modules \"adore_v2x_sim\" and \"adore_if_v2x\" cannot be found. One fix is to manually build each 1. cd to the top level of the adore project 2. source the adore.env file into your current interactive shell</p> <pre><code>source adore.env\n</code></pre> <p>Alternately, you can build all of the modules by invoking the \"build_all\" target such as follows:</p> <pre><code>cd &lt;adore project root directory&gt;\nmake build_all\n</code></pre> <p>\u2139\ufe0f INFO</p> <p>By default only core ADORe modules are built. Invoke the <code>make build_all</code> target from the root ADORe directory to build every module.</p>"},{"location":"problems_and_solutions/#problem-make-error-when-running-make-commands-on-individual-modules","title":"Problem: make error when running make commands on individual modules","text":"<p>I am receiving a similar error message to this when running any make command on an individual ADORe module:</p> <pre><code>INFO: To clone submodules use: 'git submodule update --init --recursive'\nINFO: To specify alternative path for submodules use: SUBMODULES_PATH=\"&lt;path to submodules&gt;\" make build'\nadore_if_ros_msg.mk:21: *** \"ERROR: adore/adore_if_ros_msg/make_gadgets does not exist. Did you clone the submodules?\".  Stop.\n</code></pre>"},{"location":"problems_and_solutions/#solution-make-error-when-running-make-commands-on-individual-modules","title":"Solution: make error when running make commands on individual modules","text":"<p>This is occurring because by default when cloning adore submodules are not cloned recursively.</p> <p>There are three possible solutions</p> <ol> <li>source the provided top level adore.env file:</li> </ol> <pre><code>adore(master) \u2717 (0)&gt; source adore.env\nadore(master) \u2717 (0)&gt; cd adore_if_ros_msg\nadore_if_ros_msg(master) (0)&gt; make help\nUsage: make &lt;target&gt;\n  build                                    Build adore_if_ros_msg\n  clean                                    Clean adore_if_ros_msg build artifacts\n  branch_adore_if_ros_msg                  Returns the current docker safe/sanitized branch for adore_if_ros_msg\n...\n</code></pre> <ol> <li>Manually provide the SUBMODULES_PATH when invoking make on a module:</li> </ol> <pre><code>adore(master) \u2717 (0)&gt; cd adore_if_ros_msg\nadore_if_ros_msg(master) (0)&gt;  SUBMODULES_PATH=\"$(realpath ..)\" make help\nUsage: make &lt;target&gt;\n  build                                    Build adore_if_ros_msg\n  clean                                    Clean adore_if_ros_msg build artifacts\n  branch_adore_if_ros_msg                  Returns the current docker safe/sanitized branch for adore_if_ros_msg\n</code></pre> <ol> <li>Recursively clone all the submodules:</li> </ol> <pre><code>adore(master) \u2717 (0)&gt; git submodule update --init --recursive\n</code></pre> <p>For more information on this please refer to the Build System \ud83d\udd17 documentation.</p>"},{"location":"problems_and_solutions/#problem-build-fails-when-pulling-apt-dependencies","title":"Problem: Build fails when pulling apt dependencies","text":"<p>During an initial build there is a significant amount of data that is pulled and  cached from the internet. In order to lessen this burden the tool AptCacherNg is used. This added complexity has a drawback if run on an unreliable network  resulting in non-deterministic HTTP errors and corrupted apt packages and build failures.</p> <p>For more information on general caching in adore review the Caching \ud83d\udd17 documentation and for more information on how AptCacherNg works visit the project repository: https://github.com/DLR-TS/apt_cacher_ng_docker \ud83d\udd17</p> <p>After running <code>make build</code> you receive an HTTP error from APT such as the following error message:</p> <pre><code>...\n#0 6.829 Get:76 http://archive.ubuntu.com/ubuntu focal/main amd64 g++ amd64 4:9.3.0-1ubuntu2 [1604 B]\n#0 6.833 E: Failed to fetch http://archive.ubuntu.com/ubuntu/pool/universe/a/asciidoc/asciidoc-common_9.0.0~rc1-1_all.deb  503  Resource temporarily unavailable [IP: 127.0.0.1 3142]\n...\n</code></pre> <p>or</p> <pre><code>...\n=&gt; ERROR [libadore internal] load metadata for docker.io/library/alpine:3.14\n=&gt; [libadore internal] load metadata for docker.io/library/libadore_build:1d0db8b\n------\n &gt; [libadore internal] load metadata for docker.io/library/alpine:3.14\n------\nfailed to solve: alpine:3.14: failed to do request: Head \"https://registry-1.docker.io/v2/library/alpine/manifests/3.14\": dial tcp: lookup registry-1.docker.io on 127.0.0.53:53: server misbehaving\n</code></pre>"},{"location":"problems_and_solutions/#solution-build-fails-when-pulling-apt-dependencies","title":"Solution: Build fails when pulling apt dependencies","text":"<p>The following section will offer a few potential solution steps you can take to get past this issue.</p>"},{"location":"problems_and_solutions/#brute-force","title":"Brute force","text":"<p>Simply rerunning the build command can resolve the issue. Rerun the build or make command again, if the issue was intermittent it will continue at the previous  failure point.</p>"},{"location":"problems_and_solutions/#clear-apt-cacher-broken-packages","title":"Clear apt cacher broken packages","text":"<p>On unreliable connections apt cacher packages can become corrupt. This can cause build errors.</p> <p>Delete corrupted packages with the apt cacher web interface:</p> <ol> <li>navigate to http://127.0.0.1:3142/acng-report.html in your browser </li> <li>Check the: \"Validate by file name AND file directory (use with care),\" and \"then validate file contents through checksum (SLOW), also detecting corrupt files,\" check boxes.</li> <li>Then click the \"Start Scan and/or Expiration\" button.</li> <li>Then click \"Check all\" button. </li> <li>Then click \"Delete selected files\" button followed by \"Delete now\" button and close the web browser.</li> <li>Rerun the make build command.</li> </ol>"},{"location":"problems_and_solutions/#disable-apt-cacher-entirely","title":"Disable apt cacher entirely","text":"<p>APT Cacher Ng works with docker by acting as a proxy and handling any request by apt within the docker engine.  This is accomplished via the <code>DOCKER_CONFIG</code> environmental variable which by default is not set.  When invoking docker via make, as with the ADORe build system this environmental variable is set to point to the AptCacherNg service. To disable AptCacherNg use the following syntax to  disable it: </p> <ul> <li>Disable AptCacherNg for one command:</li> </ul> <pre><code>DOCKER_CONFIG= make &lt;target&gt;\n</code></pre> <ul> <li>Disable AptCacherNg for current interactive shell session:</li> </ul> <pre><code>export DOCKER_CONFIG= \n</code></pre> <p>For more information visit the help page on Disabling Apt Cacher Ng \ud83d\udd17 or the apt-cacher-ng-docker project readme:  https://github.com/DLR-TS/apt_cacher_ng_docker \ud83d\udd17</p>"},{"location":"problems_and_solutions/#problem-make-cli-fails","title":"Problem: <code>make cli</code> fails","text":"<p>When running <code>make cli</code> it fails with error: \"ERROR: Cannot extend service\"</p> <pre><code>docker cp $(docker create --rm plotlabserver_build:eeed293):/tmp/plotlabserver/plotlabserver/build \"/home/user1/workspace/adore/plotlabserver/plotlabserver\"\ncd \"/home/user1/workspace/adore/adore_cli\" &amp;&amp; \\\n    docker-compose -f /home/user1/workspace/adore/docker-compose.yaml build adore_cli \\\n                         --build-arg ADORE_CLI_PROJECT=adore_cli \\\n                         --build-arg ADORE_CLI_PROJECT_X11_DISPLAY=adore_cli_x11-display \\\n                         --build-arg UID=1000 \\\n                         --build-arg GID=1000 \\\n                         --build-arg DOCKER_GID=140 \\\n                         --build-arg ADORE_IF_ROS_TAG=75edba2 &amp;&amp; \\\n    docker-compose -f /home/user1/workspace/adore/docker-compose.yaml build adore_cli_x11-display \\\n                         --build-arg ADORE_CLI_PROJECT=adore_cli \\\n                         --build-arg ADORE_CLI_PROJECT_X11_DISPLAY=adore_cli_x11-display \\\n                         --build-arg UID=1000 \\\n                         --build-arg GID=1000 \\\n                         --build-arg DOCKER_GID=140 \\\n                         --build-arg ADORE_CLI_TAG=03ad9e7\nERROR: Cannot extend service 'adore_cli' in /home/user1/workspace/adore/adore_cli/adore_cli.yaml: services with 'depends_on' cannot be extended\nmake[2]: *** [Makefile:17: build] Error 1\nmake[1]: *** [adore_cli.mk:100: build_adore_cli] Error 2\nmake: *** [adore_cli/adore_cli.mk:91: build_fast_adore_cli] Error 2\n</code></pre>"},{"location":"problems_and_solutions/#solution-install-the-latest-version-of-docker","title":"Solution: Install the latest version of docker","text":"<p>ADORe depends on <code>docker compose</code> not <code>docker-compose</code> at some point the during its development history <code>docker-compose</code> was renamed to <code>docker compose</code>. Review the help guide for Installing Docker \ud83d\udd17 to get a  newer version of docker.</p>"},{"location":"problems_and_solutions/#do-you-have-another-problem","title":"Do You Have Another Problem?","text":"<p>Have you encountered a problem that is not documented? Create an  issue \ud83d\udd17. Chances are if you are  having an issue someone else will encounter the same issue.  Help the community and help us document the issues to improve ADORe. We are eager to help you!</p>"},{"location":"questions_and_answers/","title":"Questions and Answers","text":""},{"location":"questions_and_answers/#question-where-is-the-major-implementation-of-adore","title":"Question: Where is the major implementation of ADORe","text":"<p>The primary kernel or core of ADORe can be found in the libadore \ud83d\udd17. Secondary to this is adore_if_ros \ud83d\udd17</p>"},{"location":"quick_start/","title":"ADORe Quick Start","text":"<p>This is a quick start guide to getting up and running with ADORe with no fuss.</p> <p>To setup and configure ADORe for a first run you can run the following setup script:</p> <pre><code>bash &lt;(curl -sSL https://raw.githubusercontent.com/DLR-TS/adore_tools/master/tools/adore_setup.sh)\n</code></pre> <p>Follow any on-screen instructions when the ADORe setup script is running or you can run the installation in non-interactive/unattended mode:</p> <pre><code>bash &lt;(curl -sSL https://raw.githubusercontent.com/DLR-TS/adore_tools/master/tools/adore_setup.sh) --headless\n</code></pre> <p>This script will do the following:</p> <ul> <li>Verify that your system meets the minimum requirements to run ADORe </li> <li>Install the system dependencies GNU Make and Docker</li> <li>Clone ADORe to your home directory</li> <li>Build ADORe core components</li> </ul> <p>For a more nuanced and deeper look into getting ADORe set up please review the  Getting Started guide.</p> <p>\u26a0\ufe0f  WARNING: As a general rule you should never run shell scripts from untrusted sources. </p>"},{"location":"styleguide/","title":"Styleguide","text":""},{"location":"styleguide/#adore-style-guide","title":"ADORe Style Guide","text":"<p>For all applicable purposes the use of the ROS style guides is encouraged.</p> <p>There is one for C++ and one for Python.</p>"},{"location":"system_and_development/","title":"System and Development","text":"<p>This section will contain details on the ADORe build system, software components, and software development.</p>"},{"location":"system_and_development/#table-of-contents","title":"Table of Contents","text":""},{"location":"system_and_development/#1-system-requirements","title":"1. System Requirements","text":""},{"location":"system_and_development/#2-build-system","title":"2. Build system","text":""},{"location":"system_and_development/#3-adore-cli","title":"3. ADORe CLI","text":""},{"location":"system_and_development/#4-unit-tests","title":"4. Unit tests","text":""},{"location":"system_and_development/#5-static-checking-tools","title":"5. Static checking tools","text":""},{"location":"system_and_development/#6-anonymous-cloning","title":"6. Anonymous cloning","text":""},{"location":"system_and_development/#7-logging","title":"7. Logging","text":""},{"location":"system_and_development/#8-documentation","title":"8. Documentation","text":""},{"location":"system_and_development/#9-licensing","title":"9. Licensing","text":""},{"location":"system_and_development/#10-contributing","title":"10. Contributing","text":""},{"location":"table_of_contents/","title":"Table of Contents","text":""},{"location":"table_of_contents/#1-system-and-development","title":"1. System and Development","text":""},{"location":"table_of_contents/#2-control-system","title":"2. Control System","text":""},{"location":"table_of_contents/#3-interfaces","title":"3. Interfaces","text":""},{"location":"table_of_contents/#4-doxygen-documentation","title":"4. Doxygen Documentation","text":""},{"location":"table_of_contents/#5-problems-and-solutions","title":"5. Problems and Solutions","text":""},{"location":"table_of_contents/#6-getting-help","title":"6. Getting Help","text":""},{"location":"table_of_contents/#7-licensing","title":"7. Licensing","text":"<p>The ADORe Technical Reference Manual is divided into several distinct parts which will be outlined below.</p>"},{"location":"table_of_contents/#1-system-and-development_1","title":"1. System and Development","text":"<p>This section will contain details on the ADORe build system, software components, and software development.</p>"},{"location":"table_of_contents/#2-control-system_1","title":"2. Control System","text":"<p>This section will contain details on the ADORe control system used for decision  making, planning, control and simulation of automated vehicles..</p>"},{"location":"table_of_contents/#3-interfaces_1","title":"3. Interfaces","text":"<p>This section describes all software interfaces of ADORe.</p>"},{"location":"table_of_contents/#4-doxygen-documentation_1","title":"4. Doxygen Documentation","text":"<p>Auto generated Doxygen documentation is provide as part of the ADORe Technical  Reference Manual for the ADORe sources.</p>"},{"location":"table_of_contents/#5-problems-and-solutions_1","title":"5. Problems and Solutions","text":"<p>A collection of curated problems and solutions</p>"},{"location":"table_of_contents/#6-getting-help_1","title":"6. Getting Help","text":"<p>Are you unable to find a solution to your problem in the documentation for your problem? Then this is the place for you.</p>"},{"location":"table_of_contents/#7-licensing_1","title":"7. Licensing","text":"<p>All information pertaining to software licensing within adore.</p>"},{"location":"basic_usage/first_scenario/","title":"Running Your First Scenario","text":""},{"location":"basic_usage/first_scenario/#running-your-first-scenario","title":"Running Your First Scenario","text":"<p>So you have emergent into the world as a new born by installing ADORe while simultaneously downloading the entire internet. You look around and ahead you  spot the ADORe CLI car on the horizon...</p> <p>If you have been greeted with the ADORe CLI car then you are ready to run your first scenario!</p> <pre><code>Welcome to the ADORe Development CLI Ubuntu 20.04.6 LTS (GNU/Linux 5.19.0-45-generic x86_64)\n\n            ____ \n         __/  |_\\__\n        |           -. \n  ......'-(_)---(_)--' \n</code></pre> <p>\u2139\ufe0f INFO: If you have not seen the ADORe CLI car yet then please review the Getting Started \ud83d\udd17 guide</p>"},{"location":"basic_usage/first_scenario/#launching-the-adore-cli","title":"Launching the ADORe CLI","text":"<p>If you have seen ADORe CLI car and you have an interactive shell prompt such as the following:</p> <pre><code>ADORe CLI: adore git:(master)  (0)&gt;  \n</code></pre> <p>otherwise start the cli with:</p> <pre><code>make cli\n</code></pre>"},{"location":"basic_usage/first_scenario/#running-a-scenario","title":"Running A Scenario","text":"<p>Once in the ADORe CLI docker context \ud83d\udd17 you can run a scenario with <code>roslaunch</code>:</p> <pre><code>cd adore_scenarios\nroslaunch baseline_test.launch\n</code></pre>"},{"location":"basic_usage/first_scenario/#i-have-errors-now-what","title":"I have errors now what?","text":"<ol> <li>You can review the Problems and Solutions \ud83d\udd17 guide.</li> <li>You can Get Help \ud83d\udd17. Send us an SOS and    we will come to the rescue.</li> </ol>"},{"location":"control_system/hd_map_navigation/","title":"Hd map navigation","text":""},{"location":"control_system/hd_map_navigation/#high-definition-maps-and-navigation","title":"High-definition Maps and Navigation","text":""},{"location":"control_system/hd_map_navigation/#geoserver","title":"Geoserver","text":""},{"location":"control_system/hd_map_navigation/#lanes","title":"Lanes","text":""},{"location":"control_system/hd_map_navigation/#road2simulation","title":"Road2Simulation","text":""},{"location":"control_system/hd_map_navigation/#open-drive","title":"Open Drive","text":"<p>how to check open drive files</p>"},{"location":"control_system/hd_map_navigation/#precedence-rules","title":"Precedence Rules","text":""},{"location":"control_system/hd_map_navigation/#speed-limits","title":"Speed Limits","text":""},{"location":"control_system/hd_map_navigation/#checkpoints","title":"Checkpoints","text":""},{"location":"control_system/hd_map_navigation/#indicator-hints","title":"Indicator Hints","text":""},{"location":"control_system/hd_map_navigation/#aerial-images","title":"Aerial Images","text":""},{"location":"control_system/hd_map_navigation/#navigation-on-lanes","title":"Navigation on Lanes","text":""},{"location":"control_system/odrcheck/","title":"Odrcheck","text":"<p>https://stackoverflow.com/questions/42809088/how-to-validate-a-xml-file-with-xsd-through-xmllint</p> <pre><code>xmllint --schema ~/catkin_ws/build/adore_if_ros/_deps/xodr-src/schema/OpenDRIVE_1.4H.xsd yourfile.xodr --noout\n</code></pre>"},{"location":"interfaces/perception/","title":"Perception","text":""},{"location":"interfaces/perception/#adores-perception-interface","title":"ADORe's Perception Interface","text":"<p>An autonomous vehicle's control processes have to be provided with information about the state of the surrounding environment and the state of the vehicle itself. The vehicle has to know where it is and what is around it. The following has to be provided to the ADORe control system by the perception layer:</p>"},{"location":"interfaces/perception/#where-am-i-ego-localization-state","title":"Where am I? Ego Localization State","text":"<p>A localization state has to be provided with 10-20Hz to allow the ADORe vehicle to plan trajectories and find its way to the desired goal location. The localization state should be the current, best known estimate of the ego vehicle position and orientation in an absolute (global) frame of reference as well as dynamic states relevant for planning and control. It is made available in libadore via <code>adore::fun::AFactory::getVehicleMotionStateReader()</code> with the type <code>adore::env::VehicleMotionState9d</code>, which contains the 3d vehicle position in X, Y and Z, the vehicle yaw angle PSI, longitudinal speed vx, lateral speed vy, yaw-rate omega, longitudinal acceleration ax, measured steering angle delta and a time stamp t.</p> <p>The localization state is employed by the environment model, trajectory planners and decision making, as these require the position and orientation in an absolute frame of reference in order to relate ego state, observed traffic participants and HD-map data.</p> <p>The interface module adore_if_ros defines reception of the localization state on three different topics <code>localization</code>, <code>VEH/ax</code> and <code>VEH/steering_angle_measured</code>. The topic <code>localization</code> transports nav_msgs::Odometry, which is typically supplied by a localization node of the Perception module. The information about current acceleration and steering angle might originate the vehicle platform's ESP and both are of type <code>std_msgs::Float32</code>.</p>"},{"location":"interfaces/perception/#ego-odometry-state","title":"Ego Odometry State","text":"<p>To facilitate stable trajectory tracking by the ADORe control system, an odometry estimate should be provided with 20-50Hz, depending on the ego vehicle's dynamics. The odometry state is the current estimate of the ego vehicle progress in a relative frame of reference and is often attained by integrating velocities. See for example ROS robot_localization. The signal should be jump-free and may drift over time. The odometry state is available in libadore via <code>adore::fun::AFactory::getVehicleOdometryMotionStateReader()</code> with the type <code>adore::env::VehicleMotionState9d</code>, see above.</p> <p>The odometry state is employed by the vehicle's stabilization layer, e.g. high-frequency feedback control.</p> <p>The interface module adore_if_ros defines reception of the odometry state on the topics <code>odom</code>, <code>VEH/ax</code> and <code>VEH/steering_angle_measured</code> in the same manner as described above.</p> <p>If a perception system does not supply a separate odometry estimate, it is possible to just use the localization state here, e.g. in ROS terms relay <code>localization</code> to <code>odom</code>.</p>"},{"location":"interfaces/perception/#what-do-i-see-traffic-participant-set","title":"What do I see? Traffic Participant Set","text":"<p>In order to make ADORe vehicles react to other traffic participants and obstacles, the perception layer should provide frequently updated traffic participant sets. A traffic participant set can be the result of the Perception layer's object detection, tracking and fusion.  It should contain all objects which are currently believed to be in the vicinity of the ego vehicle. It is available in libadore via <code>adore::env::AFactory::getTrafficParticipantSetReader()</code> and contains objects of type <code>adore::env::traffic::Participant</code>. Participants are represented as boxes which have to define at least position in X, Y, Z, yaw-angle, longitudinal and lateral speed, yaw-rate, length, width and a time stamp that corres\u1e55onds to the given participant's state.</p> <p>The interface module adore_if_ros defines reception of the traffic participant set on the topic <code>traffic</code> with the ros message type <code>adore_if_ros_msg::TrafficParticipantSet</code>. </p>"},{"location":"interfaces/perception/#unclassifiable-clutter","title":"Unclassifiable Clutter","text":"<p>It may not be possible to find a good object-oriented representation for some things in the environment of the vehicle. This could for example be the case for clutter on the side of the road. Unspecific areas to be avoided by the autonomous vehicle can be provided as a list of cylinders to the collision-detection module.</p> <p>In libadore the set of static obstacles is made available via <code>adore::env::AFactory::getStaticObstaclesPredictionSetReader()</code> with the type <code>adore::env::OccupancyCylinderPredictionSet</code>.</p> <p>The interface module adore_if_ros defines reception of the obstacle set on the topic <code>ENV/Prediction/static</code> with the type <code>adore_if_ros_msg::OccupancyCylinderPredictionSet</code>.</p>"},{"location":"interfaces/perception/#traffic-control-devices","title":"Traffic Control Devices","text":"<p>Observations about traffic lights or other traffic control devices such as stop signs have to be supplied to the control system to stop the ego vehicle at for example red-lights and to allow to predict that other traffic participants will stop at red-ligths too. The concept of controlled connections is used to specify which route along the lane-graph may be traversed: A connection is identified by a tuple of points, defining entry and exit of a controlled zone. The connection state defines the mode of traversal. A controlled connection associates a mapping from time to the expected state, which should at least define the current state and may be used to define predictions of future states.</p> <p>In libadore the set of known connections and connection states is accessible via <code>adore::env::AFactory::getControlledConnectionFeed()</code>, which supplies objects of type <code>adore::env::ControlledConnection</code>.</p> <p>The interface module adore_if_ros defines reception of observations/predictions about traffic control devices on the topic <code>ENV/tcd</code> with the type <code>adore_if_ros_msg::TCDConnectionStateTrace</code>.</p>"},{"location":"interfaces/ros_integration/","title":"Ros integration","text":""},{"location":"interfaces/ros_integration/#adore-interfacing-with-ros","title":"ADORe interfacing with ROS","text":"<p>ADORe core functionality is provided by the system-independent c++ library libadore.  The module adore_if_ros integrates library functionality into a ROS environment:  Control processes in <code>libadore/apps</code> are wrapped by corresponding ROS nodes. The communication between different ROS nodes and their corresponding control processes is transported via messages defined in adore_if_ros_msg or in the ROS standard message packages.  The module adore_if_ros defines transformations between libadore internal c++ classes and ROS messages. The ROS parameter server provides values for the libadore internal parameters. <code></code></p>"},{"location":"interfaces/ros_integration/#control-processes-and-ros-nodes","title":"Control Processes and ROS Nodes","text":"<p>The header <code>adore_if_ros/baseapp.h</code> defines a base class, which is used in adore_if_ros control process nodes in order to execute and schedule the control process defined in <code>libadore/apps</code>. </p> <p>The most important ros nodes provided by the adore_if_ros package are:</p> purpopse ROS node description planning&amp;control adore_checkpoint_controller_node monitors a predefined list of manual checkpoints and enforces driver interaction before vehicle may continue over a given checkpoint planning&amp;control adore_feedback_controller_node tracks the current trajectory and outputs steering and acceleration actuator values planning&amp;control adore_lfbehavior_node lane following only tactical layer planning&amp;control adore_lvprovider_node computes and publishes lane following and lane change views planning&amp;control adore_mission_controller_node vehicle's top level state automaton responsible for switching between driving/parking and next goal location planning&amp;control adore_monitor0_node computes some zero order logic propositions about vehicle state, e.g. IN_COLLISION planning&amp;control adore_navigation_node publishes navigation information (cost to go) for lanes near vehicle planning&amp;control adore_tactical_planner_node requests plans from trajectory planners and selects one of the results for execution planning&amp;control adore_trajectory_planner_lc_node plans lane change trajectories planning&amp;control adore_trajectory_planner_lf_node plans lane following trajectories planning&amp;control adore_trajectory_planner_lm_node plans lane merge trajectories (finalization of lane change maneuver) environment model adore_mapprovider_node publishes static lane and precedence information near vehicle environment model adore_prediction_filter filters traffic participant motion predictions for relevance to the ego vehicle environment model adore_prediction_provider comutes motion predictions in form of occupied space time for traffic participants detected near ego vehicle environment model area_of_effect_provider computes area that is accessible to ego vehicle environment model speedlimit_provider publishes speedlimit information near ego vehicle environment_model adore_crosstraffic_provider Monitors prediction of other traffic participants and tests for intersection of cross-traffic with lane following view. In case of crosstraffic intersecting the lane following view, the nearest intersection with a feasible stopping position is published on the topic ENV/ConflictSet. The node may be extended in the future to publish also all intersection points after the first potential stopping position. simulation adore_ci_terminator_node terminates an automatic simulation simulation adore_objectdetectionmodel_node simulation module, which transfers information about objects near vehicle from simulation topic to ego vehicle topic simulation adore_scheduler_node controls simulation time and advances simulation time according to slowest process simulation adore_timer_node constrols simulation time and advances simulation time according to system time (when not paused) simulation adore_vehiclemodel_node controls vehicle state in simulation according to scenario initialization and control inputs simulation adore_odometrymodel_node simulates typical errors for odometry based state estimates simulation adore_localizationmodel_node simulates typical errors for GPS-localization based state estimates"},{"location":"interfaces/ros_integration/#communication-patterns","title":"Communication Patterns","text":"<p>The header <code>adore/mad/com_patterns.h</code> in libadore defines different abstract communication pattners, which are realized in <code>adore_if_ros/ros_com_patterns.h</code> with the help of ROS's publisher/subscriber principle.</p>"},{"location":"interfaces/ros_integration/#data-exchange-and-topic-definition","title":"Data Exchange and Topic Definition","text":"<p>In order to define the availability of different data sources and sinks in a system independent way, libadore makes use of an abstract factory pattern. Three abstract factories are defined in libadore for the data exchange of the environment model <code>adore/env/afactory.h</code>, the control functions <code>adore/fun/afactory.h</code> and simulation data (ground truth) <code>adore/sim/afactory.h</code>.</p> <p>The concrete factories in adore_if_ros, <code>envfactory.h</code>, <code>funfactory.h</code> and <code>simfactory.h</code> define the ROS topics on which data is exchanged, the message format in which data is exchanged, the transformation method to translate between ROS messages and c++ objects and create ROS Publisher and Subscriber instances to facilitate the transport. The concrete factories reference transformation classes defined in <code>adore_if_ros/conversions</code></p>"},{"location":"interfaces/ros_integration/#parameters","title":"Parameters","text":"<p>The abstract factory defined in <code>adore/params/afactory.h</code> is realized by <code>adore_if_ros/paramsfactory.h</code>: The concrete instances define parameter paths and names used in the ROS environment and query the parameter server.</p>"},{"location":"interfaces/ros_integration/#ros-namespaces","title":"ROS Namespaces","text":"<p>ADORe discriminates namespaces of multiple vehicles. Nodes, communication topics and parameters of a given vehicle are grouped in a collective namespace, for example <code>/vehicle0/</code>. This allows to simulate multiple autonomous vehicles in the same namespace. An arbitrary namespace can be given to each vehicle, but it must be distinct. The namespace <code>/SIM</code> is reserved for simulation data, meaning the ground truth of the simulation. Accordingly the topic <code>/SIM/traffic</code> will contain all participant's error-free states, while <code>/vehicle0/traffic</code> contains observations of vehicle0 about other traffic participants. Similarly <code>/SIM/v2x</code> contains all transmitted V2X messages and <code>/vehicle0/v2x/incoming</code> contains messages received by vehicle0.</p>"},{"location":"interfaces/sumo/","title":"Sumo","text":""},{"location":"interfaces/sumo/#automatic-sumo-integration","title":"Automatic SUMO integration","text":"<p>The cmake files of the sub-project sumo_if_ros are configured to automatically download and install SUMO in the folder catkin_ws/src/adore/sumo. To trigger the automatic installation, build sumo_if_ros:</p> <pre><code>cd ~/catkin_ws/src/adore\ncatkin build sumo_if_ros\n</code></pre> <p>The ros node sumo_if_ros/sumotraffic2ros advances SUMO time steps according to the ADORe simulation time and exchanges data between SUMO and ROS. See section adore_if_ros_demos for examples.</p>"},{"location":"interfaces/sumo/#manual-sumo-integration","title":"Manual SUMO integration","text":"<p>The following steps can be found in the SUMO documentation and have been slightly modified to attribute for file paths.</p> <p>Install a complete instance of sumo in the src folder:</p> <pre><code> sudo apt-get install cmake python g++ libxerces-c-dev libfox-1.6-dev libgdal-dev libproj-dev libgl2ps-dev swig\n\n cd ~/catkin_ws/src/adore\n git clone --recursive https://github.com/eclipse/sumo\n export SUMO_HOME=\"$PWD/sumo\"\n\n mkdir sumo/build/cmake-build &amp;&amp; cd sumo/build/cmake-build\n cmake ../..\n make -j$(nproc)\n</code></pre> <p>The files for TraCI/c++ interfacing with sumo are located here:</p> <pre><code>sumo/src/utils/traci/TraCIAPI.h\nsumo/src/utils/traci/TraCIAPI.cpp\nsumo/src/foreign/tcpip/socket.h\nsumo/src/foreign/tcpip/socket.cpp\nsumo/src/foreign/tcpip/storage.h\nsumo/src/foreign/tcpip/storage.cpp\nsumo/src/traci-server/TraCIConstants.h\nsumo/src/libsumo/TraCIDefs.h\n</code></pre> <p>If you start sumo with the following parameters:</p> <pre><code>cd ${SUMO_HOME}\n./bin/sumo --remote-port 1337 -c tests/complex/tutorial/quickstart/data/quickstart.sumocfg --step-length 0.01\n</code></pre> <p>The TraCI client can be connected as follows:</p> <pre><code>TraCIAPI client;\nclient.connect(\"localhost\", 1337);\n</code></pre>"},{"location":"interfaces/sumo/#generate-a-network-file","title":"Generate a network file","text":"<p>One option is to convert OpenDrive files directly:</p> <p>See sumo doc on netgenerate:</p> <pre><code>netconvert\u00a0--opendrive\u00a0myOpenDriveNetwork.xodr\u00a0-o\u00a0mySUMOnetwork.net.xml --offset.disable-normalization \n</code></pre> <p>Another option is to convert maps, which are readable by adore, into SUMO PlainXML format SUMO PlainXML specification: ADORe provides a <code>plainxmlexporter</code> binary, available from the selected binary folder, e.g. <code>install/lib/adore_if_ros</code>. Provide one or more map file paths as argument to binary in order to create PlainXML output <code>output.nod.xml</code> node defintions, <code>output.edg.xml</code> edge definitions and <code>output.con.xml</code> connection definitions. Currently, xodr and r2s maps can be read and converted. The parameters for plainxmlexporter are <code>[plot] infile1[,transform] [infile2[,transform]] ... outfile</code>, where plot allows immediate output of loaded files to plotlab, each infile specifies path to a map file and outfile defines prefix of Plain-XML output files.  Road2Simulation input files (file1.r2sl, file1.r2sr) have to be specified as (file1.r2s) in a single infile name. The transform arguments allow to enable/disable application of transforms specified in the OpenDrive header. The resulting PlainXML files can be further converted to a Net-XML format using sumo <code>netconvert</code>.</p> <p>Here is an example:</p> <pre><code>cd ~/catkin_ws\n\nprefix=src/adore/adore_if_ros_demos/tracks/r2s/tost2dlr\n\ninstall/lib/adore_if_ros/plainxmlexporter $prefix.r2s $prefix\n\nsrc/adore/sumo/bin/netconvert \\\n  --node-files=$prefix.nod.xml \\\n  --edge-files=$prefix.edg.xml \\\n  --connection-files=$prefix.con.xml \\\n  --output-file=$prefix.net.xml\n</code></pre>"},{"location":"interfaces/sumo/#define-a-route-description","title":"Define a route description","text":"<p>Define a file routes.xml schema, which contain vehicle and flow.</p> <pre><code>&lt;routes&gt;\n    &lt;vType id=\"traffic\" accel=\"0.8\" decel=\"4.5\" sigma=\"0.5\" length=\"5\" maxSpeed=\"70\"/&gt;\n    &lt;flow id=\"id\" type=\"traffic\" begin=\"0\" end=\"3600\" probability=\"0.1\" from=\"start\" to=\"end\" /&gt;\n&lt;/routes&gt;\n</code></pre>"},{"location":"interfaces/sumo/#define-a-re-router-in-additional-file","title":"Define a re-router in additional file","text":"<p>Example for circular track can be found here</p> <pre><code>&lt;additionals&gt;\n    &lt;rerouter id=\"rerouter_0\" edges=\"-1.0.00\"&gt;\n        &lt;interval end=\"1e9\"&gt;\n           &lt;destProbReroute id=\"-1.157.08\"/&gt;\n        &lt;/interval&gt;\n    &lt;/rerouter&gt;\n    &lt;rerouter id=\"rerouter_1\" edges=\"-1.157.08\"&gt;\n        &lt;interval end=\"1e9\"&gt;\n           &lt;destProbReroute id=\"-1.0.00\"/&gt;\n        &lt;/interval&gt;\n    &lt;/rerouter&gt;\n&lt;/additionals&gt;\n</code></pre>"},{"location":"licensing/license_check/","title":"License check","text":""},{"location":"licensing/license_check/#how-to-check-licenses","title":"How to check licenses","text":"<p>Ubuntu comes with a license checker:</p> <pre><code> sudo apt-get install licensecheck\n</code></pre> <p>Before checking license, remove unnecessary files for release</p> <pre><code>./tools/release_purge.sh\n</code></pre> <p>Check for files, which do not contain EPL-2.0:  Run the following in adore folder.</p> <pre><code>licensecheck . -r|egrep -ve \".png|.gif|.r2s|.jpg|build|sumo|java_v2x|.cmake|CMakeFiles|.gitlab-ci.yml|.vscode|Eclipse Public License 2.0\"\n</code></pre>"},{"location":"modules/adore/","title":"Index","text":""},{"location":"modules/adore/#automated-driving-open-research-adore","title":"Automated Driving Open Research (ADORe)","text":"<p>Eclipse ADORe is a modular software library and toolkit for decision making, planning, control and simulation of automated vehicles.  ADORe provides:</p> <ul> <li>Algorithms and data models applied in real automated driving system for motion planning and control</li> <li>Mechanisms for safe interaction with other CAVs, infrastructure, traffic management, interactions with human-driven vehicles, bicyclists, pedestrians</li> <li>Integration with typical tools and formats such as ROS, SUMO, CARLA, OpenDrive, Road2Simulation, ITS-G5 V2X (MAPEM, SPATEM, DENM, MCM, SREM)</li> </ul> <p>The ADORe library (libadore) is written in system-independent c++. For execution and application it is coupled with ROS (adore_if_ros). Building and execution occurs in docker containers. </p>"},{"location":"modules/adore/#overview","title":"Overview","text":"<p>An ADORe control system works in concert with a perception stack (not provided) to control an autonomous vehicle platform. Using V2X radio messages, a list of detected objects and ego vehicle position and velocity, the ADORe control system provides control inputs to a vehicle platform in order to steer it along a given high-definition roadmap to the desired goal location. </p>"},{"location":"modules/adore/#example-application","title":"Example application","text":"<p>The following video shows an automated vehicle controlled by ADORe in an urban setting in Braunschweig, Germany: </p>"},{"location":"modules/adore/#documentation","title":"Documentation","text":"<p>In order to get started, it is advised to first check system requirements, follow the installation instruction and then try out the demo scenarios.</p> <ul> <li>Github Pages</li> <li>System requirements</li> <li>Getting started</li> <li>Executable ROS demo scenarios</li> <li>Technical Reference Manual</li> </ul>"},{"location":"modules/adore_cli/","title":"adore_cli","text":"<p>The adore_cli project provides a runtime docker context for adore. It provides </p>"},{"location":"modules/adore_cli/#getting-started","title":"Getting started","text":"<p>Docker and make must be installed to use this project</p> <ol> <li>clone the repository</li> <li>run the provided make target to launch the cli</li> </ol> <pre><code>make cli\n</code></pre>"},{"location":"modules/adore_if_carla/","title":"Index","text":""},{"location":"modules/adore_if_carla/#adore_if_carla","title":"adore_if_carla","text":"<p>An interface package, which enables ADORe to control CARLA autonomous vehicles  via carla-ros-bridge.</p> <p>Note: adore_if_carla is experimental</p>"},{"location":"modules/adore_if_carla/#prerequsits","title":"Prerequsits","text":"<p>The following tools must be installed and configured for your system: - nvida-docker2 nvidia-docker2 must be installed on the host system. Instructions can be found  here: https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/install-guide.html</p> <p>Alternatively, you can run the provided setup target to install nvidia-docker2  on ubuntu:</p> <pre><code>make install_nvidia_docker2\n</code></pre> <ul> <li>make</li> <li>docker</li> </ul>"},{"location":"modules/adore_if_carla/#getting-started","title":"Getting Started","text":"<ol> <li>Install nvida-docker2</li> <li>Source the adore environment:</li> </ol> <pre><code>cd ../\nsource adore.env\n</code></pre> <p>Alternatively, you can directly provide the <code>SUBMODULES_PATH</code> such as the  following: </p> <pre><code>SUBMODULES_PATH=\"$(realpath ../)\" make &lt;target&gt;\n</code></pre> <ol> <li>Build adore_if_carla with provided build target:</li> </ol> <pre><code>make build\n</code></pre> <p>During build, the Dockerfile of the carlasimulator/ros-bridge is built and the  carlasim/carla:0.9.13 docker image is pulled from dockerhub. Grab a coffee,  carla is &gt;17GB.</p> <ol> <li>Start the adore_if_carla docker context with the provided target:</li> </ol> <pre><code>make up\n</code></pre> <ol> <li>Run a scenario</li> <li>There is a demo scenario provided: adore_scenarios/demo014_adore_if_carla.launch. This demo can be run with: </li> </ol> <pre><code>make run_demo_carla_scenario\n</code></pre> <p>or  ```bash cd .. make cli cd adore_scenarios roslaunch .launch"},{"location":"modules/adore_if_carla/adore_if_carla/","title":"adore_if_carla","text":""},{"location":"modules/adore_if_ros/","title":"Index","text":""},{"location":"modules/adore_if_ros/#adore_if_ros","title":"adore_if_ros","text":"<p>The adore ros interface, project folder. Content can be found in subfolder adore_if_ros.</p>"},{"location":"modules/adore_if_ros/#getting-started","title":"Getting Started","text":"<p>This module requires make and docker installed and configured for your user.</p>"},{"location":"modules/adore_if_ros/#building","title":"Building","text":"<p>To build libadore run the following:</p> <pre><code>make build\n</code></pre>"},{"location":"modules/adore_if_ros/#testing","title":"Testing","text":"<p>To run unit tests run the following target:</p> <pre><code>make test\n</code></pre>"},{"location":"modules/adore_if_ros/adore_if_ros/","title":"Index","text":""},{"location":"modules/adore_if_ros/adore_if_ros/#adore_if_ros","title":"adore_if_ros","text":"<p>A catkin package, which generates ROS nodes for ADORe automated driving - src folder: .cpp process wrappers for ROS - include/adore_if_ros folder: Concrete factory implementations for libadore. Realization of information exchange via ROS.</p>"},{"location":"modules/adore_if_ros_msg/","title":"Index","text":""},{"location":"modules/adore_if_ros_msg/#adore-ros-message-repository","title":"ADORe ROS Message Repository","text":"<p>ADORe is an open source toolkit for automated vehicle control and decision making, with the main repository eclipse/adore. ADORe can be coupled with ROS. This repository defines ROS messages used for interaction with ADORe through ROS. A detailed list of ROS messages and the typical topics can be found in the subfolder.</p>"},{"location":"modules/adore_if_ros_msg/#build-status","title":"Build Status","text":""},{"location":"modules/adore_if_ros_msg/#structure","title":"Structure","text":"<p>On this level the repository is a docker and make wrapper for the actual content in the module subfolder.</p>"},{"location":"modules/adore_if_ros_msg/#getting-started","title":"Getting Started","text":""},{"location":"modules/adore_if_ros_msg/#prerequsits","title":"Prerequsits","text":"<p>This project requires docker and make installed and configured for your user.</p>"},{"location":"modules/adore_if_ros_msg/#building","title":"Building","text":"<p>To build adore_if_ros_msg run the following on the top level of the repository:</p> <pre><code>make\n</code></pre>"},{"location":"modules/adore_if_ros_msg/#build-artifacts","title":"Build Artifacts","text":"<p>To consume this module you must: 1. Build the project with make 2. Install or source the module with one of the provided methods 3. Add adore_if_ros_msg to your CMakeLists.txt with find_package and catkin_package</p> <p>Once build via make this project offers the multiple options for  consuming/installing the module via the adore_if_ros_msg/build directory.</p>"},{"location":"modules/adore_if_ros_msg/#raw-message-header-files","title":"Raw message header files","text":"<p>After running make raw message files will be located at  adore_if_ros_msg/build/devel/include/adore_if_ros_msg</p>"},{"location":"modules/adore_if_ros_msg/#installation-debian-archive","title":"Installation: Debian archive","text":"<p>After running make a debian archive will be located in adore_if_ros_msg/build  which can be installed via dpkg:</p> <pre><code>dpkg -i adore_if_ros_msg/build/*.deb\n</code></pre>"},{"location":"modules/adore_if_ros_msg/#installation-system-context","title":"Installation: System context","text":"<p>You can directly install the adore_if_ros_msg module into your system context  with cmake:</p> <pre><code>cd adore_if_ros_msg/build cmake .. &gt; /dev/null 2&gt;&amp;1 || true \ncmake --install . \n</code></pre>"},{"location":"modules/adore_if_ros_msg/#sourceing-cmake-install-context","title":"Sourceing: cmake install context","text":"<p>A Cmake install context is provided upon build which can be added during cmake  configure to your prefix path. When configuring a build add  adore_if_ros_msg/build/install to your CMAKE_PREFIX_PATH:</p> <pre><code>...\ncmake .. -DCMAKE_PREFIX_PATH=$(realpath adore_if_ros_msg/build/install)\n...\n</code></pre>"},{"location":"modules/adore_if_ros_msg/#adding-adore_if_ros_msg-to-your-cmakeliststxt","title":"Adding adore_if_ros_msg to your CMakeLists.txt","text":"<p>Once installed or sourced via the previously described methods you can consume the adore_if_ros_msg module with CMake by: 1. Using find_package in your CMakeLists.txt to include adore_if_ros_msg</p> <pre><code>find_package(catkin REQUIRED COMPONENTS\n  ...\n  adore_if_ros_msg\n  ...\n)\n</code></pre> <ol> <li>Adding adore_if_ros_msg to catkin_package in your CMakeLists.txt:</li> </ol> <pre><code>catkin_package(\n  CATKIN_DEPENDS\n    ...\n    adore_if_ros_msg \n    ...\n)\n</code></pre>"},{"location":"modules/adore_if_ros_msg/adore_if_ros_msg/","title":"Index","text":""},{"location":"modules/adore_if_ros_msg/adore_if_ros_msg/#message-definitions-for-ros-interface-of-adore","title":"Message definitions for ROS interface of adore","text":"<p>In order to communicate with ADORe in ROS this package should be used. By separating adore_if_ros and adore_if_ros_msg, interacting components are independent from adore source code. Message types from common_msgs and std_msgs are preferredly employed for communication with external modules.  Internal messages will be mainly specified as user defined messages. All message headers shall be time-stamped with the true UTC time from the GPS module (or simulation equivalent).</p>"},{"location":"modules/adore_if_ros_msg/adore_if_ros_msg/#from-vehicle-base-system-to-adore","title":"From vehicle base system to adore","text":"<ul> <li>measured steering wheel angle in rad: <ul> <li>std_msgs::Float32</li> <li>/vehicle0/VEH/steering_angle_measured</li> </ul> </li> <li>wheel speeds (speed above ground in m/s), FL,RL,RR,FR<ul> <li>std_msgs::Float32MultiArray</li> <li>/vehicle0/VEH/wheel_speed</li> </ul> </li> <li>automatic control enabled<ul> <li>std_msgs::Bool</li> <li>/vehicle0/VEH/AutomaticControlState/acceleration</li> <li>/vehicle0/VEH/AutomaticControlState/accelerationActive</li> <li>/vehicle0/VEH/AutomaticControlState/steering</li> </ul> </li> <li>yaw-rate measured by ESP (rad/s)<ul> <li>std_msgs::Float32</li> <li>/vehicle0/VEH/yaw_rate</li> </ul> </li> <li>acceleration measured by ESP (m/s\u00b2, ax, ay, az) <ul> <li>std_msgs::Float32</li> <li>/vehicle0/VEH/ax</li> </ul> </li> <li>indicator state: left/right<ul> <li>std_msgs::Bool</li> <li>/vehicle0/VEH/IndicatorState/left</li> </ul> </li> <li>gear state (0:Park, 1: Drive, 2: Reverse, 3: Neutral): <ul> <li>std_msgs::Int8</li> <li>/vehicle0/VEH/gear_state</li> </ul> </li> </ul>"},{"location":"modules/adore_if_ros_msg/adore_if_ros_msg/#from-adore-to-vehicle-base-system","title":"From adore to vehicle base system","text":"<ul> <li>control input: longitudinal acceleration request (m/s\u00b2): <ul> <li>std_msgs::Float32</li> <li>/vehicle0/FUN/MotionCommand/acceleration</li> </ul> </li> <li>control input: steering wheel angle request (rad): <ul> <li>std_msgs::Float32</li> <li>/vehicle0/FUN/MotionCommand/steeringAngle</li> </ul> </li> <li>indicator input: left/right <ul> <li>std_msgs::Bool</li> <li>/vehicle0/FUN/IndicatorCommand/left</li> </ul> </li> <li>gear request (0:Park, 1: Drive, 2: Reverse, 3: Neutral): <ul> <li>std_msgs::Int8</li> <li>/vehicle0/FUN/GearSelectionCommand</li> </ul> </li> </ul>"},{"location":"modules/adore_if_ros_msg/adore_if_ros_msg/#from-sensors-to-adore","title":"From sensors to adore","text":"<ul> <li>Localization based ego state estimate (Position xyz UTM (current tile) in m, rotation around xyz in rad, velocity linear in vehicle coordinates m/s, velocity rotational rad/s): <ul> <li>nav_msgs::Odometry</li> <li>/vehicle0/localization</li> </ul> </li> <li>Odometry based ego state estimate (Position xyz in m in arbitrary frame, rotation around xyz in rad, velocity linear in vehicle coordinates m/s, velocity rotational rad/s): <ul> <li>nav_msgs::Odometry</li> <li>/vehicle0/odom</li> </ul> </li> <li>observation of other traffic participants<ul> <li>object oriented information: Specify geometric state, type, indicator/lights</li> <li>adore_if_ros_msgs::TrafficParticipantSet</li> <li>/vehicle0/traffic</li> </ul> </li> </ul>"},{"location":"modules/adore_if_ros_msg/adore_if_ros_msg/#adore-internal","title":"adore internal","text":"<ul> <li>ENV (environment representations)<ul> <li>road marking/ drivable lane: Border<ul> <li>adore_if_ros_msg::Border</li> <li>/vehicle0/ENV/Border</li> </ul> </li> <li>traffic light, traffic sign, precedence rules<ul> <li>static precedence rule<ul> <li>adore_if_ros_msg::Precedence</li> <li>/vehicle0/ENV/Precedence</li> </ul> </li> <li>tcd controlled state of a connection<ul> <li>adore_if_ros_msg::TCDConnectionState</li> <li>/vehicle0/ENV/TCDConnectionState</li> </ul> </li> </ul> </li> <li>parking spot: ParkingSpot, tbd</li> <li>logical propositions about environment and ego state<ul> <li>adore_if_ros_msg::Proposition</li> <li>/vehicle0/ENV/Propositions</li> </ul> </li> <li>prediction of space occupied by other traffic participants in the future<ul> <li>adore_if_ros_msg::OccupancyCylinderPredictionSet</li> <li>/vehicle0/ENV/Prediction/expected - the expected behavior</li> <li>/vehicle0/ENV/Prediction/worstcase - the worst-case behavior</li> <li>/vehicle0/ENV/Prediction/desired - the desired behavior of an agent</li> </ul> </li> <li>space that may be affected by ego vehicle<ul> <li>adore:if_ros_msg::AreaOfEffect</li> <li>/vehicle0/ENV/areaofeffect</li> </ul> </li> </ul> </li> <li>FUN (control functions)<ul> <li>Trajectory to be executed<ul> <li>adore_if_ros_msg::SetPointRequest</li> <li>/vehicle0/FUN/SetPointRequest</li> </ul> </li> <li>Nominal Trajectory, which could be executed if emergency maneuver is not triggered<ul> <li>adore_if_ros_msg::SetPointRequest</li> <li>/vehicle0/FUN/NominalTrajectory</li> </ul> </li> <li>low level emergency breaking: <ul> <li>adore_if_ros_msg::TerminalRequest</li> <li>/vehicle0/FUN/TerminalRequest</li> </ul> </li> <li>navigation goal: current target point for navigation node<ul> <li>adore_if_ros_msg::NavigationGoal</li> <li>/vehicle0/FUN/NavigationGoal</li> </ul> </li> <li>Request to plan trajectories <ul> <li>adore_if_ros_msg::PlanningRequest</li> <li>/vehicle0/FUN/PlanningRequest</li> </ul> </li> <li>Trajectory planning result, reply to PlanningRequest<ul> <li>adore_if_ros_msg::PlanningResult</li> <li>/vehicle0/FUN/PlanningResult</li> </ul> </li> </ul> </li> </ul>"},{"location":"modules/adore_if_ros_msg/adore_if_ros_msg/#simulation","title":"Simulation","text":"<ul> <li>simulation time<ul> <li>std_msgs::Float64</li> <li>/SIM/utc</li> </ul> </li> <li>state information of all traffic participants in the simulation<ul> <li>TrafficParticipantSimulation</li> <li>/SIM/traffic, /SIM/traffic/agg</li> </ul> </li> <li>reset vehicle state<ul> <li>geometry_msgs::Pose</li> <li>/vehicle0/SIM/ResetVehiclePose</li> <li>geometry_msgs::Twist</li> <li>/vehicle0/SIM/ResetVehicleTwist</li> </ul> </li> <li>vehicle state ground truth<ul> <li>nav_msgs::Odometry</li> <li>/vehicle0/SIM/state</li> </ul> </li> </ul>"},{"location":"modules/adore_if_v2x/","title":"Index","text":""},{"location":"modules/adore_if_v2x/#adore-interface-to-its-g5-v2x-radio-via-ros","title":"ADORe Interface to ITS-G5 V2X radio via ROS","text":"<p>ADORe is an open source toolkit for automated vehicle control and decision making, with the main repository eclipse/adore. ADORe can be coupled with ROS. This module contains adapters, which convert messages from v2x_if_ros_msg \"V2X ROS messages\" into adore_if_ros_msg \"ADORe ROS messages\".</p>"},{"location":"modules/adore_if_v2x/#structure","title":"Structure","text":"<p>On this level the repository is a docker and make wrapper for the actual content in the module subfolder.</p>"},{"location":"modules/adore_if_v2x/#setup","title":"Setup","text":"<p>This repository may be used on a system, which fulfills a set of requirements adore_setup. After checkout, enter make in the top level of the repository in order to build.</p>"},{"location":"modules/adore_if_v2x/adore_if_v2x/","title":"Index","text":""},{"location":"modules/adore_if_v2x/adore_if_v2x/#package-adore_if_v2x","title":"Package adore_if_v2x","text":"<p>This package contains adapters, which convert messages from v2x_if_ros into adore_if_ros_msg.</p>"},{"location":"modules/adore_scenarios/","title":"Index","text":""},{"location":"modules/adore_scenarios/#adore-ros-demos","title":"ADORe ROS Demos","text":"<p>In the following directory several demonstrations are given to showcase technical solutions on reduced examples. Their goal is to serve as venture points for setting up simulation experiments with ADORe automated vehicles. To run the demo scenarios, build the command-line-interface container and start it:</p> <pre><code>make adore_cli\n</code></pre> <p>Then navigate to the catkin workspace demo directory in the adore_cli container, export your display variable and launch the demo:</p> <pre><code>cd catkin_workspace/src/adore_if_ros_demos\nexport DISPLAY=:0\nroslaunch demo001_loadmap.launch\n</code></pre>"},{"location":"modules/adore_scenarios/#load-open-drive-tracks","title":"Load Open Drive tracks","text":"<ul> <li>file: demo001_loadmap.launch </li> <li>The ROS node \"adore_mapprovider_node\" is responsible for loading tracks, aka. roadmaps.</li> <li>Track files are specified by the local ROS parameter \"PARAM/track\". (\"local\" as in \"can be defined separately for each vehicle/agent in their respective namespace\")</li> <li>Multiple tracks may be loaded: File names have to be separated by \";\" in the \"PARAM/track\" string. </li> <li>Loading multiple tracks results in a conjunction of elements from all tracks. If road elements of different tracks are geometrically adjacent, the automation system will be able to transition between them. </li> <li>An offset may be specified for OpenDrive maps:<ul> <li>Append \",transform\" to an OpenDrive file name specified in \"PARAM/track\"</li> <li>Define west=\"x\" and south=\"y\" (lower left corner) in the header element of the OpenDrive xml file</li> <li>All elements of the file will then be shifted by (x,y)</li> </ul> </li> <li>The \"adore_mapprovider_node\" dissects the roadmap representation into lane- or road-border segments, of type \"adore::env::borderbased::Border\" </li> <li>Each \"Border\" keeps track of its marking and of the lane type between itself and its left neighbor</li> <li>Typically an automated vehicle is allowed to drive between two Borders, which enclose a lane of type \"Driving\"</li> <li>To prevent the automation system's maneuver planner from having to deal with the complete map at once, the mapprovider will send \"Borders\" in the vicinity of the vehicle via the rostopic \"ENV/Border\". <ul> <li>See also: The ros topic and message type documentation adore_if_ros_msg/Readme.md</li> <li>The distance at which \"Border\" objects become visible is controlled by the parameter \"PARAMS/map_provider/r\"</li> </ul> </li> <li>If the parameter \"PARAMS/map_provider/activate_plotting\" is set to \"true\", the overall map will be displayed in figure 1 </li> </ul> <p>Overview plot of tracks loaded by demo001: </p>"},{"location":"modules/adore_scenarios/#computation-of-a-navigation-function","title":"Computation of a navigation function","text":"<ul> <li>file: demo002_navigatemap.launch</li> <li>The ROS node \"adore_navigation_node\" helps an ADORe automated vehicle to navigate to its destination.</li> <li>A destination for the automated vehicle may be set, by sending a \"NavigationGoal\" message on the topic \"ENV/NavigationGoal\"</li> <li>Similar to the \"adore_mapprovider_node\", tracks specified in \"PARAMS/track\" are loaded into memory</li> <li>When such a \"NavigationGoal\" message is received, the distance along the road network towards the destination is computed for each \"Border\" object in memory</li> <li>Based on the same ideas of locality as the \"adore_mapprovider_node\", the \"adore_navigation_node\" sends distance values for each \"Border\" object in the vicinity of the vehicle on the ROS topic \"ENV/NavigationData\".</li> <li>If the parameter \"PARAMS/navigation/active_plotting_global\" is set to true, the navigation function will be shown color-coded for the overall map in figure 1. (Red is far, and green is near. Please note: In the example below, non-drivable sidewalks are color-coded red at \"infinite\" cost.)</li> </ul> <p>Color-coded navigation function plotted by demo002: </p>"},{"location":"modules/adore_scenarios/#simulation-of-automated-lane-following","title":"Simulation of Automated Lane Following","text":"<ul> <li>file: demo003_lanefollowing.launch</li> <li>Demo 003 shows how to simulated an automated vehicle with a minimal set of components. Several nodes are introduced in addition to the \"adore_mapprovider_node\" described above.</li> <li>To create a dynamic simulation, the ROS node \"adore_timer_node\" publishes a globally synchronous time signal on the topic \"/SIM/utc\". The process is started in a shell, in order to accept user input: By pressing enter, the simulation can be paused and resumed.</li> <li>The namespace \"SIM\" is here reserved for simulation information, e.g. global, synchronous, precise states accessible to simulation modules. </li> <li>Topics under \"SIM\" can generally only be accessed by simulation nodes and never by \"production\" nodes. Simulation nodes, such as sensor models, vehicle models, network models etc. relay the information to sensor- and environment information topics of a specific agent/vehicle.</li> <li>In its most basic form, the \"adore_vehiclemodel_node\" serves both as a vehicle model and an idealized vehicle state sensor: It receives the time signal \"/SIM/utc\" and the vehicle control inputs \"FUN/MotionCommand/steeringAngle\" and \"FUN/MotionCommand/acceleration\" and integrates the vehicle state up to the most recent time value. This vehicle state is published on the topic \"/agentnamespace/odom\". (Note: In order to insert an error model for the state measurement, the output topic of \"adore_vehicle_model\" could be re-routed to an error-model node by declarations in the launch file.)<ul> <li>In order to set initial conditions for simulations, the state of the vehicle can be reset by sending messages on the topics \"SIM/ResetVehiclePose\" and \"SIM/ResetVehicleTwist\".</li> <li>The state of the vehicle is always maintained for the center of the rear axle.</li> <li>The \"adore_vehiclemodel_node\" also publishes its state information on the simulation topic \"/SIM/traffic\". In following exapmles, the topic is used to exchange state information between multiple, simulated agents/vehicles. A parameter \"agentnamespace/simulationID\" is introduced. This unique id is attached to the state information published on \"/SIM/traffic\", to discriminate between different agents during simulation.</li> </ul> </li> <li>The \"production\" part of the automated lane following system consists of two control nodes in this example: A feed-forward motion planner running at 10 Hz and a stabilizing feed-back controller running at 100Hz.<ul> <li>The motion planner \"adore_lfbehavior_node\" generates trajectories for lane-following only. It receives \"road marking information\" on the topic \"ENV/Border\" from the \"adore_mapprovider_node\" and ego state information on the \"odom\" topic. It computes a reference trajectory consisting of desired vehicle states and feed-forward control inputs. (Desired states are given for the center of rear axle). The reference trajectories are published on the topic \"FUN/SetPointRequest\".</li> <li>The feed-back controller receives the reference trajectories and the current vehicle state and computes and publishes a control input signal (\"FUN/MotionCommand/steeringAngle\" and \"FUN/MotionCommand/acceleration\") with the goal of minimizing the distance between actual vehicle state and current reference vehicle state.</li> </ul> </li> <li>The process \"adore_borderbird_node\" plots a simplistic representation of the local scene from a \"birds-eye\" perspective: The local \"road marking information\", the reference trajectory (displayed in red) and the current vehicle state (blue box with triangle).</li> </ul> <p>Local scene for lane following automation in demo003: </p>"},{"location":"modules/adore_scenarios/#lane-following-with-three-automated-vehicles","title":"Lane following with three automated vehicles","text":"<ul> <li>file: demo004_follow_vehicle_mult.launch</li> <li>In order to simulate multiple vehicles, multiple instances of \"adore_vehiclemodel_node\", \"adore_mapprovider_node\",  \"adore_feedbackcontroller_node\" and \"adore_lfbehavior_node\" have to be started.<ul> <li>Note: Each set of nodes is started in a separate namespace, e.g. \"/vehicle0\", \"/vehicle1\" and \"/vehicle2\"</li> </ul> </li> <li>A simple sensor model is introduced, which allows a vehicle to detect positions of other vehicles: <ul> <li>For each vehicle, an \"adore_objectdetectionmodel_node\" reads state information of traffic participants from the topic \"/SIM/traffic\" and \"/SIM/traffic/agg\". This information is published on the vehicle internal topic \"/agentnamespace/traffic\". </li> <li>The topic \"/SIM/traffic\" publishes individual state updates. On the topic \"/SIM/traffic/agg\", aggregate information in the form of multiple vehicle states per message is published. </li> <li>The \"sensor modeling\" part of the simple node is actually a range limit for detections.</li> <li>Detections of other traffic participants are colored black in the figure 2 plot.</li> </ul> </li> <li>Each vehicle can be parameterized independently in its namespace: The global speed limit of vehicle2, \"/vehicle2/PARAMS/tactical_planner/global_speed_limit\", is set to a small value in the launch file. This will result in vehicle 0 and 1 catching up  and following.<ul> <li>Note: The parameter can be manipulated during simulation with the shell command \"rosparam set /vehicle2/PARAMS/tactical_planner/global_speed_limit 10\". Of course, other parameters can also be changed during simulation.</li> </ul> </li> </ul> <p>Two fast vehicles following a slow vehicle in demo004: </p>"},{"location":"modules/adore_scenarios/#lane-following-with-adore-automated-vehicle-and-multiple-sumo-vehicles","title":"Lane following with ADORe automated vehicle and multiple SUMO vehicles","text":"<ul> <li>file: demo005_follow_vehicle_sumo.launch </li> <li>SUMO  is a free and open traffic simulation toolsuite. It is used in this example to represent manually driven vehicles in the vicinity of the ADORe automated vehicle.</li> <li>SUMO has to be downloaded and installed. These steps will be executed by the cmake script of the SUMO-ROS interface \"sumo_if_ros\".  So before launching the demonstration, make sure to execute:</li> </ul> <pre><code>cd ~/catkin_ws/src/adore\ncatkin build sumo_if_ros\nexport SUMO_HOME=~/catkin_ws/src/adore/sumo\n</code></pre> <ul> <li>The demo005 launch file starts a SUMO simulation. Parameters include SUMO simulation setup, (here: demo005.sumocfg), as well as a simulation step size.</li> <li>The node \"sumotraffic2ros_node\" uses SUMO's TraCI interface to synchronize simulation time and to exchange traffic participant state information.<ul> <li>On changes of the time signal \"/SIM/utc\" the SUMO simulation is advanced.</li> <li>Traffic information from the topic \"/SIM/traffic\" is pusblised to SUMO, so that SUMO vehicles may react to ADORe vehicles.</li> <li>Traffic information from SUMO is published on the \"/SIM/traffic/agg\".</li> </ul> </li> <li>In this example, a single ADORe vehicle instance is created in addition to the SUMO traffic.</li> <li>NOTE: The timer is started in \"paused\" state, to allow startup of all process before simulation begins. Visual output will only be generated as soon as time advances, so make sure to \"unpause\" the timer node.</li> </ul> <p>Several SUMO vehicles and one ADORe automated vehicle in demo005: </p>"},{"location":"modules/adore_scenarios/#lane-following-and-navigation-to-a-goal-location","title":"Lane following and navigation to a goal location","text":"<ul> <li>file: demo006_lanefollowing_navigation.launch</li> <li>Demo006 showcases a vehicle automatically driving to a given goal position. The setup is similar to demo003, yet a \"adore_navigation_node\" is additionally started.</li> <li>The launch file sets an initial NavigationGoal. During simulation, the goal point can be changed by publishing a ROS message. For example with the following shell command:</li> </ul> <pre><code>rostopic pub /vehicle0/ENV/NavigationGoal adore_if_ros_msg/NavigationGoal '{target: {x: 360, y: 162, z: 0}}'\n</code></pre> <ul> <li>As a reaction, the navigation function should be re-computed and the vehicle should change its course to drive to the new location.</li> <li>Note: Currently, the vehicle stops at the end of a \"Border\", which has minimum distance to the navigation goal. </li> <li>NOTE: The timer is started in \"paused\" state, to allow startup of all process before simulation begins. Visual output will only be generated as soon as time advances, so make sure to \"unpause\" the timer node.</li> </ul> <p>Vehicle turning at intersection and stopping at goal in demo006: </p>"},{"location":"modules/adore_scenarios/#prediction","title":"Prediction","text":"<ul> <li>file: demo007b_precedence_no_rules.launch</li> <li>In demo007b two ADORe automated vehicles approach an unsignalized intersection and avoid a collision by predicting possible paths of the vehicle.</li> <li>Vehicle0 approaches from west and turns north, vehicle1 crosses the intersection straight from south to north.</li> <li>The adore_prediction_provider node is executed by each vehicle and computes for each detected traffic participant a set of locations that might be covered by the given traffic participant in the future.</li> <li>Predictions are published on the topic \"ENV/Prediction\"</li> <li>A collision detection module (for example in adore_lfbehavior_node) receives the predictions and intersects possible plans of the ego vehicle with possible positions of other traffic participants </li> <li>In case of a conflict, a planned trajectory may not be executed and thus the vehicle decelerates</li> <li>In the given demonstration scenario, the vehicles initially both react to each other and decelerate</li> <li>As vehicle0 is approaching a turn, it is initially slower and reaches standstill before vehicle1</li> <li>As soon as vehicle0 is stopped, vehicle1's path is clear and it may continue across the intersection</li> <li>Obviously, such a coordination at an intersection is suboptimal and therefore the next section outlines improved behavior through prediction in combination with static precedence rules </li> </ul>"},{"location":"modules/adore_scenarios/#prediction-and-precedence-rules","title":"Prediction and precedence rules","text":"<ul> <li>file: demo007a_precedence_right.launch</li> <li>In demo007a two ADORe automated vehicles approach an unsignalized intersection and solve the impeding conflict according to a static set of precedence rules</li> <li>The setup is similar to demo007b, with the addition of static precedence rules defined for the intersection</li> <li>The static precedence rule set is loaded from a file by adore_mapprovider_node </li> <li>The file path is given by the parameter \"PARAMS/precedence\"</li> <li>adore_mapprovider_node disseminates all static precedence rules near the vehicle via the topic \"ENV/Precedence\"</li> <li>A precedence file specifies a list of connection pairs (four coordinates) \"X0,Y0,Z0;X1,Y1,Z1 &gt; X2,Y2,Z2;X3,Y3,Z3\"</li> <li>A connection pair \"Ca &gt; Cb\", Ca=\"c0;c1\"=\"X0,Y0,Z0;X1,Y1,Z1\", Cb=\"c2;c3\"=\"X2,Y2,Z2;X3,Y3,Z3\" defines that a connection passing along c0 and c1 has precedence over a connection passing along c2 and c3.</li> <li>The adore_prediction_filter node receives the static precedence rules as well as the predictions of adore_prediction_provider</li> <li>The prediction filter selects the high priority connections in the path of the ego vehicle and removes all branches from the prediction tree, which lie on corresponding low priority connections</li> <li>The modified prediciton set is published again and allows to apply only those predictions to collision detection, which do not violate the precedence of the ego vehicle</li> <li>In demo007a vehicle1 has precedence over vehicle0 and by considering the filtered predictions of vehicle0 may cross the intersection unhindered.</li> </ul> <ul> <li>file: demo007c_precedence_left.launch</li> <li>Demo007c is similar to demo007a, but the precedence file is modified to give precedence to the connection leading from west to north</li> <li>Accordingly, vehicle0 crossses the intersection before vehicle1.</li> </ul>"},{"location":"modules/adore_scenarios/#straight-line-predictions","title":"Straight-line Predictions","text":"<ul> <li>file: demo007d_sl45_right_turn_pedestrian.launch</li> <li>In demo007d an ADORe vehicle approaches a right turn at an intersection. A stationary object (pedestrian) is detected. As the vehicle starts to enter the turn, the pedestrian starts crossing the road.</li> <li>As the pedestrian is not using a known crosswalk, the prediction module uses only the pedestrian's linear motion vector to extrapolate future positions.</li> <li>In the current version only the two prediction modes 'along lane' (demo007a-c) and 'straight' are available (demo007d). The successfule lane matching of objects determines, which mode is used.</li> <li>Demo007d gives an example for triggering events in a simulation: Using the transform node of the topic_tools ROS package, the velocity of the pedestrian is set according to the position of vehicle0:</li> </ul> <pre><code>rosrun topic_tools transform /vehicle0/odom /pedestrian0/SIM/ResetVehicleTwist geometry_msgs/Twist 'geometry_msgs.msg.Twist(linear=geometry_msgs.msg.Vector3(x=2 if m.pose.pose.position.x&gt;662 else 0, y=0.0, z=0.0), angular=geometry_msgs.msg.Vector3( x= 0.0, y= 0.0, z= 0.0))' --import geometry_msgs std_msgs\n</code></pre>"},{"location":"modules/adore_scenarios/#traffic-lights","title":"Traffic Lights","text":"<ul> <li>file: demo008_sumo_trafficlights.launch</li> <li>Demo008 showcases traffic lights detected via MAPEM and SPATEM V2X radio messages</li> <li>MAPEM messages are sent by roadside units at intersections to inform about the intersection geometry and topology.</li> <li>SPATEM messages are sent by roadside units at intersections to inform about current (and optionally future) traffic light signal phases.</li> <li>A co-simulation with SUMO is run. The SUMO scenario does not specify any traffic, so SUMO manages only the traffic lights in the given scenario.</li> <li>Besides publishing to the topic /SIM/traffic, the node sumo_if_ros/sumotraffic2ros_node publishes to the topics /SIM/v2x/MAPEM and /SIM/v2x/SPATEM.</li> <li>The messages published to /SIM/v2x are wrappers, which contain ROS message equivalents of ETSI ITSG5 messages as payload, as well as simulation meta information, such as sending position and signal strength. </li> <li>A node of type v2xsim/channel_sim_node is run for vehicle0. The channel_sim_node decides based on ego position, sender position and signal strength, whether a message on the topic /SIM/v2x is received. Received messages are copied from the simulation topic /SIM/v2x to the vehicle specific topic /vehicle0/v2x/incoming. </li> <li>The package adore_if_v2x is the interface to ITSG5 ROS message equivalents. The node adore_if_v2x/v2x_trafficlights_node receives MAPEM and SPATEM messages from /vehicle0/v2x/incoming and converts these into ADORe internal data formats published on /vehicle0/ENV/tcd.</li> <li>In case of a different sensor type identifying signal phases (most likely camera-based), the information would also be published to /vehicle0/ENV/tcd.</li> <li>The topic /vehicle0/ENV/tcd transmits signal states for all known connections, agnostic to their relevance to the ego vehicle. Trajectory planning processes, such as adore_lfbehavior_node match the data to lane-following and lane-change views to determine where to stop the ego vehicle, while the adore_prediction_filter applies the signal phases to the prediction of other traffic participants near ego.</li> <li>As shown in the image below, current traffic light phases are visualized as icons as well as connection vectors crossing the intersection. </li> </ul>"},{"location":"modules/adore_scenarios/#lane-changes","title":"Lane Changes","text":"<ul> <li>file: demo009_lanechange_tostmannplatz.launch</li> <li>In demo009 a vehicle has to navigate through a complex intersection. To reach the goal point in the north-west intersection arm from the starting position in the south, multiple lane changes are required.</li> <li>The extended vehicle configuration for this scenario starts a decision making module \"adore_tactical_planner_node\", a \"adore_trajectory_planner_lf_node\" for lane following as well as two instances each of \"adore_trajectory_planner_lc_node\" and \"adore_trajectory_planner_lm_node\" for planning lane changes to the left and to the right. </li> <li>The lane change planner \"adore_trajectory_planner_lc_node\" computes trajectories for preparation and initiation of lane changes, while the lane merge planner \"adore_trajectory_planner_lm_node\" plans trajectories for the final part of the lane change, merging into the target lane.</li> <li>The decision making module sends PlanningRequest messages and receives PlanningResult messages from active trajectory planners. It selects \"the best\" trajectory and sends it to the trajectory tracking controller to be executed. In order to allow comparison of trajectories, each planner provides a set of different objective values for a valid trajectory. The \"adore_tactical_planner_node\" compares trajectories purely on their validity and the objective value of \"MinimumNavigationCostOnLane\".</li> <li>Indicators are currently not visualized, but their activation can be examined on the topic /vehicle0/FUN/IndicatorCommand. Each PlanningResult specifies which indicator has to be activated. The activation command is generated by the tactical planner node based on the selected trajectory. </li> </ul>"},{"location":"modules/adore_scenarios/#background-satellite-images","title":"Background satellite images","text":"<ul> <li>file: demo010_sat_images.launch</li> <li>Using satellite images as a background for the lane geometry can help to check for mapping errors.</li> <li>Demo010 loads satellite images from a publicly available geo-server.</li> <li>A lane model for a small section of the city of Duesseldorf, Germany (51.21564822166936, 6.775329829362242) is shown on top of the satellite images.</li> <li>The ROS node adore_if_ros/plot_satimages_node requests plotlabserver to plot url-based images near the position of the ego vehicle.</li> <li>The plotlabserver will download and cache the images. (Plotting may stall when images are displayed for the first time.)</li> <li>Parameters \"plotoptions/tiles/base_url\" and \"plotoptions/tiles/width_meters\" control geo-server url, image resolution and image size in m:</li> </ul> <pre><code>    &lt;param name=\"plotoptions/tiles/base_url\" value=\"https://www.wms.nrw.de/geobasis/wms_nw_dop?language=ger&amp;#038;SERVICE=WMS&amp;#038;REQUEST=GetMap&amp;#038;VERSION=1.3.0&amp;#038;layers=nw_dop_rgb&amp;#038;styles=&amp;#038;width=400&amp;#038;height=400&amp;#038;CRS=EPSG:25832&amp;#038;FORMAT=image/jpeg&amp;#038;bbox=\" type=\"str\" /&gt; \n    &lt;param name=\"plotoptions/tiles/width_meters\" value=\"100\" type=\"double\" /&gt; \n</code></pre>"},{"location":"modules/adore_scenarios/#faster-slower-than-real-time-and-background-simulation","title":"Faster (slower) than real-time and background simulation","text":"<ul> <li>file: demo011_scheduler.launch</li> <li>The scenario of this example is equivalent to demo006_lanefollowing_navigation.launch</li> <li>The approach to simulating the scenario has been adapted for \"headless\" applications, such as batch simulations for validation and machine learning. </li> <li>The previously used simple timer (which allowed to pause and unpause simulation) has been replaced with a scheduler: The adore_scheduler_node communicates with all time-critical processes and waits for the finalization of a given time slice, before advancing the simulated time. The scheduler allows the simulation to run faster than real-time, in case sufficient computational ressources are available. (This should typically be the case for the given scenario.) In case the scenario is complicated and the computational resources are limited, the scheduler allows to simulate slower than real-time, with all time-critical processes executing as if sufficient resources permitted finalization of computations in time.</li> <li>The demo's run time on an Intel Core i7 notebook is about 17s (computation time) versus 120s of simulated time. (Disclaimer: Of course the demo case is very simplified and the runtime factor for a simulation with other traffic participants and multiple trajectory planners for ego might be considerably worse. The presented setup merely serves to showcase that a runtime factor differing from 1 can be achieved.)</li> <li>The simulation automatically terminates, if the vehicle is near the goal location or if 130s of simulation time have been surpassed. </li> <li>The adore_monitor0_node publishes a proposition on the topic \"/vehicle0/ENV/propositions\" with term=\"NEAR_GOAL\" and value true or false.</li> <li>A topic_tools \"transform\" node has been added to the launch file, which filters the propositions topic for NEAR_GOAL=true and publishes to /SIM/terminate.</li> <li>The adore_ci_terminator_node listens on /SIM/utc and /SIM/terminate topics and will shut down the simulation accoordingly (the flag required=\"true\" has been added to the node tag and the node self-terminates to shutdown simulation)</li> <li>An argument has been added to the demo launch file, which allows to run the simulation with or without graphical output:</li> </ul> <pre><code>roslaunch demo011_scheduler.launch headless:=true\n</code></pre>"},{"location":"modules/adore_scenarios/#speed-limit-adherence","title":"Speed Limit adherence","text":"<ul> <li>file: demo012_lanefollowing_w_speedlimit.launch</li> <li>This is an adaption of demo003_lanefollowing.launch which adds the speedlimit_provider node. The ego will slow down a bit near the start and again after about 300m.</li> <li>The file speedlimit.txt is used as a source for speed limits in a simple csv. Each line has 5 values, the first is the speed limit in m/s and the next two pairs represent the start x/y and stop x/y.</li> <li>The speedlimit_provider node reads this file in, given as a parameter, and will publish each set of data if the ego is close enough. This information is then used in the computation of the laneview provider. There a speedlimit function is derived for each lane, from the global speed limit and each set of speed limit data where both start and stop points are within the lane.</li> <li>The demo csv file contains some off lane speed limits to show that these are ignored.</li> </ul>"},{"location":"modules/adore_scenarios/#simulation-of-localization-errors-and-odometry-drift","title":"Simulation of localization errors and odometry drift","text":"<p>Automated Vehicles often determine their position via (differential) GPS, comparison of LIDAR measurements with an a-priori map, other optical features with an a-priori map or a combination thereof. New observations may lead to a correction of the belief where the AV is located. Feed-back controllers with a high gain should not be directly exposed to such jumps in the belief state, as that could lead to instability or at least uncomfortable control actions. Wheel-speed/rotation measurements, inertial measurement units and optical-differential measurements are often summerized as odometry based information: A common characteristic is that an odometry-based belief state is jump free but drifts (slowly diverges from ground truth with time). Its drift error rules out comparison of the odometry belief against globally referenced information, as is the case for trajectory planners and HD-maps in ADORe. By employing localization-based states for predictive feed-forward computation and odometry-based states for feedback, the problems of both signals can be compensated. Such a technique appears to be state-of-the-art and is for example utilized by the ROS navigation stack.</p> <p>The approach is demonstrated for ADORe as follows: Error models for localization and odometry are used in the modified configuration-file demo_vehicle_cfg01b.launch. Both make use of the ground truth (luckily avaliable in simulation), which is supplied by the vehicle model on the topic <code>/vehicle0/SIM/state</code> and supply their error-augmented outputs via <code>/vehicle0/localization</code> and <code>/vehicle0/odom</code>.  - file: demo013_localization_errors.launch - The vehicle model is started with the argument <code>external_ego_measurement_models:=true</code> to suppress error-free outputs. In this case the vehicle model only supplies the topic <code>/vehicle0/SIM/state</code>. - The additional process adore_odometrymodel_node supplies the odometry estimate - The additional process adore_localizationmodel_node supplies the localization estimate</p> <p>The following image shows a situation from demo013, with ground-truth vehicle state given in red (also vehicle image) and localization belief state in blue. The setup allows the trajectory planner to assess whether a localization update necessitates sharp control action or whether the offset may be corrected over a prolonged period of time. The trajectory planner selects the initial state of the new trajectory at the old reference state in odometry coordinates and calculates where the initial state is located under consideration of the new localization update. Thus guaranteeing continuity in odometry coordinates while also allowing to react to changes in the localization frame.</p> <p></p> <p>Note:  - The operation of the vehicle in error-free conditions may be simulated by supplying the argument <code>external_ego_measurement_models:=false</code> (or no argument) to the vehicle model and by starting neither adore_odometrymodel_node nor adore_localizationmodel_node. - The vehicle may be operated on purely localization information by supplying the localization state also on the topic <code>/vehicle0/odom</code> instead of the odometry state.</p>"},{"location":"modules/adore_scenarios/#carla-coupling","title":"CARLA Coupling","text":"<ul> <li>file: demo014_adore_if_carla.launch</li> <li>Note: adore_if_carla is experimental. The demo shows the the coupling of ADORe and CARLA. In order to run this demo, the adore_if_carla package needs to be built. Further instructions on that can be find in the README. To start the demo, the following steps need to be performed:</li> <li>build adore_if_carla by typing \"make\" in the adore_if_carla directory</li> <li>start CARLA by typing \"docker compose up carla\" in the adore_if_carla directory</li> <li>start the CARLA-ros-bridge by typing \"xhost local:root; docker compose up carla-ros-bridge\" in the adore_if_carla directory</li> <li>start the adore_if_carla applications by typing \"docker compose up adore_if_carla\" in the adore_if_carla directory</li> <li>start the demo014_adore_if_carla.launch of adore_if_ros_demos</li> </ul>"},{"location":"modules/adore_scheduling/","title":"Index","text":""},{"location":"modules/adore_scheduling/#adore_scheduling","title":"adore_scheduling","text":"<p>This repository provides scheduling functionalities for ADORe and its ROS interface. It contains the subprojects lib_adore_scheduling, adore_if_ros_scheduling_msg, adore_if_ros_scheduling and adore_scheduler.</p>"},{"location":"modules/adore_scheduling/#build-status","title":"Build Status","text":""},{"location":"modules/adore_scheduling/#getting-started","title":"Getting Started","text":"<p>You must have make and docker installed.</p> <ol> <li>git clone with submodules:</li> </ol> <pre><code>git clone git clone --recursive -j8 git@github.com:DLR-TS/adore_scheduling.git\n</code></pre> <ol> <li>build</li> </ol> <pre><code>make build\n</code></pre>"},{"location":"modules/adore_scheduling/adore_if_ros_scheduling/","title":"Index","text":""},{"location":"modules/adore_scheduling/adore_if_ros_scheduling/#adore_if_ros_scheduling","title":"adore_if_ros_scheduling","text":"<p>This project contains header files for the use by adore_if_ros and adore_scheduler.</p>"},{"location":"modules/adore_scheduling/adore_if_ros_scheduling/adore_if_ros_scheduling/","title":"Index","text":"<p>see the README.md file in the parent folder</p>"},{"location":"modules/adore_scheduling/adore_if_ros_scheduling_msg/","title":"Index","text":""},{"location":"modules/adore_scheduling/adore_if_ros_scheduling_msg/#adore_if_ros_scheduling_msg","title":"adore_if_ros_scheduling_msg","text":"<p>This project contains the message definition for adore_if_ros_scheduling.</p>"},{"location":"modules/adore_scheduling/adore_if_ros_scheduling_msg/adore_if_ros_scheduling_msg/","title":"Index","text":"<p>see the README.md file in the parent folder</p>"},{"location":"modules/adore_scheduling/adore_scheduler/","title":"Index","text":""},{"location":"modules/adore_scheduling/adore_scheduler/#adore_scheduler","title":"adore_scheduler","text":"<p>This project contains the ROS node for the scheduling of adore_if_ros.</p>"},{"location":"modules/adore_scheduling/adore_scheduler/adore_scheduler/","title":"Index","text":"<p>see the README.md file in the parent folder</p>"},{"location":"modules/adore_scheduling/lib_adore_scheduling/","title":"Index","text":""},{"location":"modules/adore_scheduling/lib_adore_scheduling/#lib_adore_scheduling","title":"lib_adore_scheduling","text":"<p>This project contains scheduling functions for the scheduling of ADORe.</p>"},{"location":"modules/adore_scheduling/lib_adore_scheduling/lib_adore_scheduling/","title":"Index","text":"<p>see the README.md file in the parent folder</p>"},{"location":"modules/adore_tools/","title":"ADORe Tools","text":"<p>This repository contains a collection of shell scripts and tools that support ADORe.</p>"},{"location":"modules/adore_tools/tools/","title":"Index","text":""},{"location":"modules/adore_tools/tools/#tools","title":"Tools","text":"<p>A set of useful shell scripts and other files.</p>"},{"location":"modules/adore_tools/vagrant/","title":"Vagrantfile Readme","text":"<p>In the ADORe tools/vagrant directory you will find several Vagrantfiles.  </p>"},{"location":"modules/adore_tools/vagrant/#background","title":"Background","text":"<p>This project in <code>adore_tools/vagrant</code> provides two vagrant contexts for running ADORe: - Headless context: no display, command line only - Headed context: virtual display and desktop environment</p> <p>Both contexts will have all necessary dependencies installed, ADORe cloned, and all ADORe core modules built.</p>"},{"location":"modules/adore_tools/vagrant/#getting-started","title":"Getting Started","text":"<ol> <li>Install Virtualbox: https://www.virtualbox.org/ \ud83d\udd17</li> <li>Install Vagrant: https://www.vagrantup.com/ \ud83d\udd17</li> <li>Run vagrant with the provided make targets:</li> </ol> <pre><code>make up\n</code></pre> <p>or headless:</p> <pre><code>make up_headless\n</code></pre>"},{"location":"modules/adore_tools/vagrant/#cleaning-up","title":"Cleaning Up","text":"<p>There is a make target provided to clean up the virtual machines:</p> <pre><code>make destroy\n</code></pre>"},{"location":"modules/adore_v2x_sim/","title":"Index","text":""},{"location":"modules/adore_v2x_sim/#a-basic-simulation-package-for-its-g5-v2x-radio-messages","title":"A basic simulation package for ITS-G5 V2X radio messages","text":"<p>ADORe is an open source toolkit for automated vehicle control and decision making, with the main repository eclipse/adore. ADORe can be coupled with ROS.  This module contains a basic model for simulation of v2x radio traffic exchanged between automated vehicles. Messages from v2x_if_ros_msg \"V2X ROS messages\" are exchanged between virtual stations.</p>"},{"location":"modules/adore_v2x_sim/#structure","title":"Structure","text":"<p>On this level the repository is a docker and make wrapper for the actual content in the module subfolder.</p>"},{"location":"modules/adore_v2x_sim/#setup","title":"Setup","text":"<p>This repository may be used on a system, which fulfills a set of requirements adore_setup. After checkout, enter make in the top level of the repository in order to build.</p>"},{"location":"modules/adore_v2x_sim/adore_v2x_sim/","title":"Index","text":""},{"location":"modules/adore_v2x_sim/adore_v2x_sim/#v2xsim-is-a-ros-simulation-package-for-itsg5-radio-messages","title":"v2xsim is a ROS simulation package for ITSG5 radio messages","text":"<p>For each simulated ITSG5 message X, a \"SimX.msg\" file is provided in msg folder. A SimX message transports the original ROS version of the ITSG5 message and a meta information header of type \"V2XMetaSIM\", which contains send power, send location, send time and the size of the message on the physical channgel as bytecount. A node \"channel_sim_node\" is provided by this package: The node relays messages between the simulation channel \"/SIM/v2x/X\", (where \"X\" stands for message type) and the reception and send channels of a station, \"v2x/incoming/X\" and \"v2x/outgoing/X\".</p> <pre><code>/SIM/v2x/X: SimX.msg  --&gt;  v2x/incoming/X: X.msg\n/SIM/v2x/X: SimX.msg  &lt;--  v2x/outgoing/X: X.msg\n</code></pre> <p>The channel_sim_node further receives its station's position information of type \"nav_msgs/Odometry.msg\" on topic \"odom\" in order to compare a messages send location and the station's location on reception of a message.</p>"},{"location":"modules/apt_cacher_ng_docker/","title":"apt_cacher_ng_docker","text":"<p>This project provides an APT caching service for docker saving network resources.</p> <p>apt_cacher_ng_docker provides a mechanism for running apt-cacher ng along side docker build and run.  </p>"},{"location":"modules/apt_cacher_ng_docker/#background","title":"Background","text":"<p>Repeated docker builds of large contexts can be time consuming and waste network resources. The APT package management tool can be a significant offender of this waste.  This project allows you to run an apt cacher ng service along side  your docker builds to save network resources from repeated download of apt packages resulting on significant speedup with subsequent docker builds.</p>"},{"location":"modules/apt_cacher_ng_docker/#prerequisites","title":"Prerequisites","text":"<p>requires docker, docker compose, and make installed and configured for your user.</p>"},{"location":"modules/apt_cacher_ng_docker/#usage","title":"Usage","text":"<p>Simply call the provided up target to start the apt cacher ng service:</p> <pre><code>make up\n</code></pre>"},{"location":"modules/apt_cacher_ng_docker/#setting-up-consumers","title":"Setting Up Consumers","text":"<p>There are a number of strategies for setting up a client to take advantage of this apt cacher ng service.  This section offers several consumer examples. </p>"},{"location":"modules/apt_cacher_ng_docker/#consumer-option-recommended-approach","title":"Consumer Option (Recommended Approach)","text":"<p>This is the best and recommended approach for consuming this apt cacher ng service. The result of this method will be reproducible builds e.g., regardless of weather the apt cacher ng service is used or not docker build cache will not be invalidated.</p> <ol> <li>Use  provided make target to start up the apt cacher ng service:</li> </ol> <pre><code>make up\n</code></pre> <ol> <li>Build you docker image sourcing the provided docker config in this directory(config.json):</li> </ol> <pre><code>DOCKER_CONFIG=. docker build --network host --file Dockerfile.apt_cacher_ng_consumer_recommended .\n</code></pre>"},{"location":"modules/apt_cacher_ng_docker/#consumer-option-1","title":"Consumer Option 1","text":"<p>This option requires modifying the consumer Dockerfile.  This will invalidate  your docker cache if the HTTP_PROXY variable changes. This is generally a bad  option.</p> <ol> <li>Add the following to any consumer docker containers that wish to take advantage of apt caching:</li> </ol> <pre><code>...\nRUN echo 'Acquire::http { Proxy \"http://127.0.0.1:3142\"; };' &gt;&gt; /etc/apt/apt.conf.d/01proxy\nRUN apt-get update\n...\nRUN apt-get install -y somepackage\n...\n\n</code></pre> <ol> <li>Before building the consumer image start the apt cacher ng service with the provided make target:</li> </ol> <pre><code>make start_apt_cacher_ng\n</code></pre> <ol> <li>Build your docker image with the --network flag provided as follows:</li> </ol> <pre><code>docker build --network host .\n</code></pre> <p>or try the example Dockerfile consumer provided with the project:</p> <pre><code>docker build --network host --file Dockerfile.apt_cacher_ng_consumer1 .\n</code></pre> <ol> <li>Stop the apt-cacher ng service after your container is build with the provided make target:</li> </ol> <pre><code>make stop_apt_cacher_ng\n</code></pre> <p>A complete dockerfile is provided in this project for this example (Dockerfile.apt_cacher_ng_consumer1)</p>"},{"location":"modules/apt_cacher_ng_docker/#option-2","title":"Option 2","text":"<p>This option requires modifying the consumer Dockerfile.  This will invalidate  your docker cache if the HTTP_PROXY variable changes. This is generally a bad  option.</p> <ol> <li>Add the following to any consumer docker containers that wish to take advantage of apt caching:</li> </ol> <pre><code>...\nARG HTTP_PROXY\nARG HTTPS_PROXY\nARG NO_PROXY\n\nENV http_proxy \"$HTTP_PROXY\"\nENV https_proxy \"$HTTPS_PROXY\"\nENV no_proxy \"$NO_PROXY\"\n...\nRUN apt-get update\n...\nRUN apt-get install -y somepackage\n...\n</code></pre> <ol> <li>Before building the consumer image start the apt cacher ng service with the provided make target:</li> </ol> <pre><code>make start_apt_cacher_ng\n</code></pre> <ol> <li>Build your docker image with the --network flag and --build-arg flags provided as follows:</li> </ol> <pre><code>docker build --network host --build-arg HTTP_PROXY=http://127.0.0.1:3142 --build-arg HTTPS_PROXY=\"http://127.0.0.1:3142\" .\n</code></pre> <p>or try the example Dockerfile consumer provided with the project:</p> <pre><code>docker build --network host --file Dockerfile.apt_cacher_ng_consumer2 .\n</code></pre> <ol> <li>Stop the apt-cacher ng service after your container is build with the provided make target:</li> </ol> <pre><code>make stop_apt_cacher_ng\n</code></pre> <p>A complete dockerfile is provided in this project for this example (Dockerfile.apt_cacher_ng_consumer1)</p>"},{"location":"modules/apt_cacher_ng_docker/#apt-cacher-ng-statistics-dashboard","title":"Apt-Cacher NG Statistics Dashboard","text":"<p>While Apt-Cacher is running caching statistics can be found via the web interface at: http://127.0.0.1:3142/acng-report.html</p>"},{"location":"modules/apt_cacher_ng_docker/#cache-directory","title":"Cache Directory","text":"<p>when you execute \"make up\" a docker volume is created for apt cache located in the current directory and called \".cache\". This directory cache directory is preserved regardless of the state docker on the host system.  To manually wipe this cache you can run:</p> <pre><code>make clean\n</code></pre>"},{"location":"modules/apt_cacher_ng_docker/#proxy-configuration","title":"Proxy Configuration","text":"<p>The provide apt cacher ng service works behind a proxy. To enable a proxy set the HTTP_PROXY environmental variable to your desired proxy example:</p> <pre><code>HTTP_PROXY=http://someproxy:3124 make build_apt_cacher_ng &amp;&amp; make start_apt_cacher_ng\n</code></pre> <p>The environmental variable can also be set for persistence via your preferred shell or with the following:</p> <pre><code>export HTTP_PROXY=http://someproxy:3124\n...\n...\nmake build_apt_cacher_ng &amp;&amp; make start_apt_cacher_ng\n</code></pre>"},{"location":"modules/apt_cacher_ng_docker/#disabling-apt-cacher-ng-ad-hoc","title":"Disabling Apt Cacher Ng ad hoc","text":"<p>Sometimes it may be necessary to disable Apt Cacher Ng. This can be done by  setting the environmental variable <code>APT_CACHER_NG_ENABLED</code> to false. One-off disabling apt-cacher-ng:</p> <pre><code>APT_CACHER_NG_ENABLED=false make up\n</code></pre> <p>Sometimes it may be necessary to disable apt-cacher-ng persistently in the case when it is causing issues or during CI processes. This can be done by sourcing the provided environment file:</p> <pre><code>source disable_apt_cacher_ng.env\n</code></pre> <p>\u26a0\ufe0f WARNING: This will only work with the recommended consumer approach with the DOCKER_CONFIG env var.</p>"},{"location":"modules/catkin_docker/","title":"Catkin docker","text":"<p>This is a command line tool and docker context that can generate a catkin  workspace and link precompiled catkin packages to this workspace. </p>"},{"location":"modules/catkin_docker/#prerequisites","title":"Prerequisites","text":"<p>Docker and make must be installed</p>"},{"location":"modules/catkin_docker/#creating-a-catkin-workspace","title":"Creating a catkin workspace","text":"<p>Call the provided make target:</p> <pre><code>make create_catkin_worspace SOURCE_DIRECTORY=$(realpath &lt;source directory&gt;)\n</code></pre> <p>The \"SOURCE_DIRECTORY\" must be an absolute path to a directory containing catkin packages.</p>"},{"location":"modules/ci_teststand/","title":"ci_teststand","text":"<p>todo</p>"},{"location":"modules/coordinate_conversion/","title":"Index","text":""},{"location":"modules/coordinate_conversion/#a-package-with-wgs84-tofrom-utm-coordinate-conversion","title":"A package with WGS84 to/from UTM coordinate conversion","text":"<p>ADORe is an open source toolkit for automated vehicle control and decision making, with the main repository eclipse/adore. This module contains a transform between WGS84 and UTM and is consumed by other modules.</p>"},{"location":"modules/coordinate_conversion/#build-status","title":"Build Status","text":""},{"location":"modules/coordinate_conversion/#structure","title":"Structure","text":"<p>On this level the repository is a docker and make wrapper for the actual content in the module subfolder.</p>"},{"location":"modules/coordinate_conversion/#setup","title":"Setup","text":"<p>This repository may be used on a system, which fulfills a set of requirements adore_setup. After checkout, enter make in the top level of the repository in order to build.</p>"},{"location":"modules/coordinate_conversion/#make-help-recipe","title":"make help recipe","text":"<p>To view the available make recipes run the following: ```bash make help ````</p>"},{"location":"modules/cppcheck_docker/","title":"cpplint_docker","text":"<p>This is a project offering a minimal docker environment for static checking C++ source with cppcheck.</p>"},{"location":"modules/cppcheck_docker/#description","title":"Description","text":"<p>With this project you can static check arbitrary C++ code with cppcheck. It does not require complex configurations. Clone the project and point it to your source directory. </p>"},{"location":"modules/cppcheck_docker/#getting-started","title":"Getting started","text":"<p>This project requires make and docker installed and configured for your user.</p> <ol> <li>Clone the project:</li> </ol> <pre><code>git clone git@gitlab.dlr.de:csa/cpplint.git\n</code></pre> <ol> <li>static check  a project using the provided make target:</li> </ol> <pre><code>make cppcheck CPP_PROJECT_DIRECTORY=$(realpath ./hello_world) \n\nChecking hello_world/hello_world.cpp ...\n1/2 files checked 32% done\nChecking hello_world/src/hello.cpp ...\nhello_world/src/hello.cpp:6:4: error: Array 'a[10]' accessed at index 10, which is out of bounds. [arrayIndexOutOfBounds]\n  a[10] = 0;\n   ^\nhello_world/src/hello.cpp:6:9: style: Variable 'a[10]' is assigned a value that is never used. [unreadVariable]\n  a[10] = 0;\n        ^\n2/2 files checked 100% done\nnofile:0:0: information: Cppcheck cannot find all the include files (use --check-config for details) [missingInclude]\n</code></pre>"},{"location":"modules/cpplint_docker/","title":"cpplint_docker","text":"<p>This is a project offering a minimal docker environment for linting C++ projects with cpplint</p>"},{"location":"modules/cpplint_docker/#description","title":"Description","text":"<p>With this project you can lint arbitrary C++ code with cpplint. It does not  require complex configurations. Clone the project and point it to your source  directory. </p> <p>By default cppclint and clang-format use the Google style guide for linting and formatting.</p>"},{"location":"modules/cpplint_docker/#getting-started","title":"Getting started","text":"<p>This project requires make and docker installed and configured for your user.</p> <ol> <li>Clone the project:</li> </ol> <pre><code>git clone git@gitlab.dlr.de:csa/cpplint.git\n</code></pre> <ol> <li>Build the docker container:</li> </ol> <pre><code>make build\n</code></pre> <ol> <li>lint a project using the provided make target:</li> </ol> <pre><code>make lint CPP_PROJECT_DIRECTORY=$(realpath ./hello_world)\n\n=== CCLINT ===\n\n      \u2717 hello_world/hello_world.cpp\n        #0: No copyright message found.  You should have a line: \"Copyright [year] &lt;Copyright Owner&gt;\"  [legal/copyright] [5]\n        #3: Missing space before {  [whitespace/braces] [5]\n        #3: Extra space before ( in function call  [whitespace/parens] [4]\nDone processing hello_world/hello_world.cpp\n\n      \u2717 hello_world/include/hello.h\n        #0: No copyright message found.  You should have a line: \"Copyright [year] &lt;Copyright Owner&gt;\"  [legal/copyright] [5]\nDone processing hello_world/include/hello.h\n\n      \u2717 hello_world/src/hello.cpp\n        #0: No copyright message found.  You should have a line: \"Copyright [year] &lt;Copyright Owner&gt;\"  [legal/copyright] [5]\n        #4: Missing space before {  [whitespace/braces] [5]\n        #5: Tab found; better to use spaces  [whitespace/tab] [1]\nDone processing hello_world/src/hello.cpp\n\n** LINT SUCCEEDED ** (0.023 seconds)\n\n\nTotal errors found: 7\nDone.\n</code></pre>"},{"location":"modules/cpplint_docker/#cpplintcfg","title":"CPPLINT.cfg","text":"<p>Add a CPPLINT.cfg to your project source tree to modify the behavior of cpplint. from the cpplint help:</p> <pre><code>   CPPLINT.cfg has an effect on files in the same directory and all\n    sub-directories, unless overridden by a nested configuration file.\n</code></pre> <p>Go to https://github.com/cpplint/cpplint for more information on possible config options.</p>"},{"location":"modules/cpplint_docker/#lintfix-target","title":"lintfix target","text":"<p>This project also includes clang-format to automate fixing of lint errors. Some linting errors can be fixed automatically with clang-format. To fix fixable  lint errors run the provided make target:</p> <pre><code>make lint CPP_PROJECT_DIRECTORY=$(realpath ./hello_world)\n</code></pre> <p>The CPP_PROJECT_DIRECTORY will be recursively searched and fixed with  clang-format using by default the Google C++ style guild.</p> <p>To use an alternate style guide please modify the .clang-format config file. </p>"},{"location":"modules/libadore/","title":"Index","text":""},{"location":"modules/libadore/#libadore","title":"libadore","text":"<p>libadore is the core implementation the ADORe framework</p>"},{"location":"modules/libadore/#background","title":"Background","text":"<p>libadore is a collection of libraries for education and research on Cooperative Automated Vehicles (CAV). Its goal is to support different automation levels and different driving capabilities with a set of well defined interfaces, data models and controller implementations. We strive to minimize controller  complexity and the amount of required data by making use of abstractions. The  library is developed system independently in c++. In order to test and simulate  concrete instances of automation designs, a generic interface to middleware  software and data transmission is provided. </p> <p> FIG: libadore/ADORe Architecture</p>"},{"location":"modules/libadore/#components","title":"Components","text":"<p>This section will offer a description and background on all available Components within libadore.</p> <ul> <li>libadore/adore/fun - motion planning, decision making and control for AV</li> <li>libadore/adore/env - environment description, data representation for AV</li> <li>libadore/adore/view - data abstraction interface for AV, decouples fun and env</li> <li>libadore/adore/mad - math, algorithms and abstract data structures supporting AV</li> <li>libadore/adore/apps - middleware independent implementation of adore applications</li> <li>libadore/adore/params - abstract parameter descriptions for AV</li> <li>libadore/adore/sim - simulation tools</li> <li>libadore/adore/if_xodr - conversion of OpenDrive tracks into internal representation</li> <li>libadore/adore/if_r2s - conversion of Road2Simulation tracks into internal representation</li> </ul>"},{"location":"modules/libadore/#component-descriptions","title":"Component Descriptions","text":"<p>libadore bundles several packages: Four central packages of the library are ENV for environment models, FUN for planner and controller implementations, VIEW for abstraction and decoupling of environment models and APPS for definition of  applications based on a combination of ENV, FUN and VIEW. The package SIM  defines models for the simulation of one or more automated vehicles. The package PARAMS lists sets of parameters required for vehicle automation. The package MAD defines a useful toolset for mathematical operations, algorithms and data  structures. The package if_xodr converts OpenDrive  road models to an internal road-map model.</p> <p>One important design principle we strive to uphold is to avoid direct  dependencies between models and controllers/planners. The VIEW package therefore defines several task specific data abstraction interfaces. A set of models from  ENV is used to provide data to a view, while a controller uses the high-level  data provided by the view, without knowing the underlying models. This allows us to easily exchange, re-organize and extend environment models. Furthermore,  several alternative controller implementations for a specific task can be  compared without implementing a task specific data refinement multiple times.</p> <p>Another important principle is to avoid depending on specific communication or  middleware frameworks. The APPS package defines several \"proto\" processes, which interconnect model data acquisition, abstraction/refinement and planning and  control modules, without referencing concrete middleware services. Communication services are decoupled using an  abstract factory pattern. Several packages (ENV, FUN, SIM) define abstract factories to standardize their  data exchange. A separate project adore_if_ros implements middleware-dependent concrete factory and concrete product  implementations.</p> <p>Currently, libadore does not contain packages for sensor data fusion or  interfacing with physical sensors. Assuming a typical \"sense-plan-act\"  architecture, all vehicle automation modules downstream of \"sense\" are in the  scope of this project.</p>"},{"location":"modules/libadore/#build-status","title":"Build Status","text":""},{"location":"modules/libadore/#getting-started","title":"Getting Started","text":"<p>This module requires make and docker installed and configured for your user.</p>"},{"location":"modules/libadore/#building","title":"Building","text":"<p>To build libadore run the following:</p> <pre><code>make build\n</code></pre>"},{"location":"modules/libadore/#testing","title":"Testing","text":"<p>To run unit tests run the following target:</p> <pre><code>make test\n</code></pre>"},{"location":"modules/libadore/#static-checking","title":"Static checking","text":"<p>There are several included static analysis tools. To run them use the following:</p> <pre><code>make lint\n</code></pre> <pre><code>make cppcheck\n</code></pre>"},{"location":"modules/libadore/#external-libraries","title":"External Libraries","text":"<p>libadore depends on several external libraries that do not provide distributions.  They are packaged and hosted for adore via docker.io. All external libraries are located in <code>libadore/external</code>. There is a provided make file to build and publish all external libraries. By default all external libraries are disabled in the <code>.gitmodules</code> file. They have been previously  published to docker.io. In order to build them you must first enable the one  you would like to build in the <code>.gitmodules</code> file. </p> <p>\u2139\ufe0f INFO: External library submodues are disabled and will not be pulled. Enable them by modifying the <code>.gitmodules</code> and invoking 'git submodue update --init'.</p> <p>\u2139\ufe0f INFO: By default external libraries are not built. They are sourced as pre-compiled docker images from docker.io.</p>"},{"location":"modules/libadore/#license","title":"License","text":"<p>The source code and the accompanying material is licensed under the terms of the EPL v2.</p>"},{"location":"modules/libadore/#contributors","title":"Contributors","text":"<ul> <li>Daniel He\u00df</li> <li>Stephan Lapoehn</li> <li>Thomas Lobig</li> <li>Matthias Nichting</li> <li>Robert Markowski</li> <li>Jan Lauermann</li> <li>Reza Deriani</li> <li>Jonas Rieck</li> <li>Andrew Koerner</li> </ul>"},{"location":"modules/libadore/libadore/","title":"Index","text":""},{"location":"modules/libadore/libadore/#libadore","title":"libadore","text":"<p>libadore is the core implementation the ADORe framework</p>"},{"location":"modules/libadore/libadore/#background","title":"Background","text":"<p>libadore is a collection of libraries for education and research on Cooperative Automated Vehicles (CAV). Its goal is to support different automation levels and different driving capabilities with a set of well defined interfaces, data models and controller implementations. We strive to minimize controller  complexity and the amount of required data by making use of abstractions. The  library is developed system independently in c++. In order to test and simulate  concrete instances of automation designs, a generic interface to middleware  software and data transmission is provided. </p> <p> FIG: libadore/ADORe Architecture</p>"},{"location":"modules/libadore/libadore/#components","title":"Components","text":"<p>This section will offer a description and background on all available Components within libadore.</p> <ul> <li>libadore/adore/fun - motion planning, decision making and control for AV</li> <li>libadore/adore/env - environment description, data representation for AV</li> <li>libadore/adore/view - data abstraction interface for AV, decouples fun and env</li> <li>libadore/adore/mad - math, algorithms and abstract data structures supporting AV</li> <li>libadore/adore/apps - middleware independent implementation of adore applications</li> <li>libadore/adore/params - abstract parameter descriptions for AV</li> <li>libadore/adore/sim - simulation tools</li> <li>libadore/adore/if_xodr - conversion of OpenDrive tracks into internal representation</li> <li>libadore/adore/if_r2s - conversion of Road2Simulation tracks into internal representation</li> </ul>"},{"location":"modules/libadore/libadore/#component-descriptions","title":"Component Descriptions","text":"<p>libadore bundles several packages: Four central packages of the library are ENV for environment models, FUN for planner and controller implementations, VIEW for abstraction and decoupling of environment models and APPS for definition of  applications based on a combination of ENV, FUN and VIEW. The package SIM  defines models for the simulation of one or more automated vehicles. The package PARAMS lists sets of parameters required for vehicle automation. The package MAD defines a useful toolset for mathematical operations, algorithms and data  structures. The package if_xodr converts OpenDrive  road models to an internal road-map model.</p> <p>One important design principle we strive to uphold is to avoid direct  dependencies between models and controllers/planners. The VIEW package therefore defines several task specific data abstraction interfaces. A set of models from  ENV is used to provide data to a view, while a controller uses the high-level  data provided by the view, without knowing the underlying models. This allows us to easily exchange, re-organize and extend environment models. Furthermore,  several alternative controller implementations for a specific task can be  compared without implementing a task specific data refinement multiple times.</p> <p>Another important principle is to avoid depending on specific communication or  middleware frameworks. The APPS package defines several \"proto\" processes, which interconnect model data acquisition, abstraction/refinement and planning and  control modules, without referencing concrete middleware services. Communication services are decoupled using an  abstract factory pattern. Several packages (ENV, FUN, SIM) define abstract factories to standardize their  data exchange. A separate project adore_if_ros implements middleware-dependent concrete factory and concrete product  implementations.</p> <p>Currently, libadore does not contain packages for sensor data fusion or  interfacing with physical sensors. Assuming a typical \"sense-plan-act\"  architecture, all vehicle automation modules downstream of \"sense\" are in the  scope of this project.</p>"},{"location":"modules/libadore/libadore/#build-status","title":"Build Status","text":""},{"location":"modules/libadore/libadore/#getting-started","title":"Getting Started","text":"<p>This module requires make and docker installed and configured for your user.</p>"},{"location":"modules/libadore/libadore/#building","title":"Building","text":"<p>To build libadore run the following:</p> <pre><code>make build\n</code></pre>"},{"location":"modules/libadore/libadore/#testing","title":"Testing","text":"<p>To run unit tests run the following target:</p> <pre><code>make test\n</code></pre>"},{"location":"modules/libadore/libadore/#static-checking","title":"Static checking","text":"<p>There are several included static analysis tools. To run them use the following:</p> <pre><code>make lint\n</code></pre> <pre><code>make cppcheck\n</code></pre>"},{"location":"modules/libadore/libadore/#external-libraries","title":"External Libraries","text":"<p>libadore depends on several external libraries that do not provide distributions.  They are packaged and hosted for adore via docker.io. All external libraries are located in <code>libadore/external</code>. There is a provided make file to build and publish all external libraries. By default all external libraries are disabled in the <code>.gitmodules</code> file. They have been previously  published to docker.io. In order to build them you must first enable the one  you would like to build in the <code>.gitmodules</code> file. </p> <p>\u2139\ufe0f INFO: External library submodues are disabled and will not be pulled. Enable them by modifying the <code>.gitmodules</code> and invoking 'git submodue update --init'.</p> <p>\u2139\ufe0f INFO: By default external libraries are not built. They are sourced as pre-compiled docker images from docker.io.</p>"},{"location":"modules/libadore/libadore/#license","title":"License","text":"<p>The source code and the accompanying material is licensed under the terms of the EPL v2.</p>"},{"location":"modules/libadore/libadore/#contributors","title":"Contributors","text":"<ul> <li>Daniel He\u00df</li> <li>Stephan Lapoehn</li> <li>Thomas Lobig</li> <li>Matthias Nichting</li> <li>Robert Markowski</li> <li>Jan Lauermann</li> <li>Reza Deriani</li> <li>Jonas Rieck</li> <li>Andrew Koerner</li> </ul>"},{"location":"modules/libadore/libadore/adore/apps/","title":"Index","text":""},{"location":"modules/libadore/libadore/adore/apps/#adore-apps","title":"adore apps","text":"<p>In the context of the adore individual process-modules are called apps. The library adore apps provides middleware agnostic function modules which facilitate creating the respective binaries of a middleware dependent implementation of adore.</p>"},{"location":"modules/libadore/libadore/adore/env/","title":"Index","text":""},{"location":"modules/libadore/libadore/adore/env/#adore-env","title":"adore env","text":"<p>adore env defines models for the environment of an autonomous vehicle.</p>"},{"location":"modules/libadore/libadore/adore/fun/","title":"Index","text":""},{"location":"modules/libadore/libadore/adore/fun/#adore-fun","title":"adore fun","text":"<p>adore fun defines functional components for automated vehicles, such as controllers and planners.</p>"},{"location":"modules/libadore/libadore/adore/if_r2s/","title":"Index","text":""},{"location":"modules/libadore/libadore/adore/if_r2s/#adore-if_r2s","title":"adore if_r2s","text":"<p>adore if_r2s defines a file loader for Road2Simulation based HD maps.</p>"},{"location":"modules/libadore/libadore/adore/if_xodr/","title":"Index","text":""},{"location":"modules/libadore/libadore/adore/if_xodr/#adore-if_xodr","title":"adore if_xodr","text":"<p>adore if_xodr defines a file loader for OpenDrive based HD maps.</p>"},{"location":"modules/libadore/libadore/adore/mad/","title":"Index","text":""},{"location":"modules/libadore/libadore/adore/mad/#adore-mad","title":"adore mad","text":"<p>adore mad supplies usefule mathematical tools, algorithms and datastructures.</p>"},{"location":"modules/libadore/libadore/adore/params/","title":"Index","text":""},{"location":"modules/libadore/libadore/adore/params/#adore-params","title":"adore params","text":"<p>The params library abstracts the use of parameters to configure the runtime behaviour of adore apps in a middleware agnostic way.</p>"},{"location":"modules/libadore/libadore/adore/sim/","title":"Index","text":""},{"location":"modules/libadore/libadore/adore/sim/#adore-sim","title":"adore sim","text":"<p>The sim library abstracts functionality to control a simulation of the car automation functions or helps interfacing with a simulation environment. As with the other adore libraries, it is middleware agnostic.</p>"},{"location":"modules/libadore/libadore/external/","title":"libadore external libraries","text":"<p>This project contains all external libraries consumed by libadore not available in central repositories</p> <p>This project contains submodules and a Dockerfile necessary to build and package all external libadore libraries.</p>"},{"location":"modules/libadore/libadore/external/#external-libraries","title":"External Libraries","text":"<p>All external libraries are located in <code>libadore/external</code>. There is a provided make file to build and publish all external libraries. By default all external libraries are disabled in the <code>.gitmodules</code> file. They have been previously  published to docker.io. In order to build them you must first enable the one  you would like to build in the <code>.gitmodules</code> file. </p> <p>\u2139\ufe0f INFO: External library submodues are disabled and will not be pulled. Enable them by modifying the <code>.gitmodules</code> and invoking 'git submodue update --init --recursive'. <code>make build_&lt;some lib&gt;</code> will fail without cloning submodules.</p> <p>\u2139\ufe0f INFO: By default external libraries are not built. They are sourced as pre-compiled docker images from docker.io. </p>"},{"location":"modules/libadore/libadore/external/#getting-started","title":"Getting Started","text":"<p>Docker and Make are required</p>"},{"location":"modules/libadore/libadore/external/#build","title":"build","text":"<p>to build all external libraries run make:</p> <pre><code>make\n</code></pre> <p>you can build specific libraries with the provided make targets for example:</p> <pre><code>make build_xodr\n</code></pre>"},{"location":"modules/libadore/libadore/external/#build-artifacts","title":"Build Artifacts","text":"<p>Once a particular library is built artifacts can be found at: - /build - /build/.deb - /build/install - cmake install context"},{"location":"modules/libadore/libadore/external/#tags","title":"Tags","text":"<p>Catch2:v2.10.2 dlib:v19.24 csaps-cpp:master osqp:v0.6.2 qpOASES:268b2f2 xodr:a751ae6 osqp:latest </p>"},{"location":"modules/lizard_docker/","title":"cpplint_docker","text":"<p>This is a project offering a minimal docker project for doing code complexity  analysis with (terryyin/lizard)[https://github.com/terryyin/lizard]</p>"},{"location":"modules/lizard_docker/#description","title":"Description","text":"<p>With this project you can use the lizard tool to calculate code complexity.</p>"},{"location":"modules/lizard_docker/#getting-started","title":"Getting started","text":"<p>This project requires make and docker installed and configured for your user.</p> <ol> <li>Clone the project:</li> </ol> <pre><code>git clone git@gitlab.dlr.de:csa/lizard.git\n</code></pre> <ol> <li>Build the docker container:</li> </ol> <pre><code>make build\n</code></pre> <ol> <li>Use lizard on a project using the provided make target:</li> </ol> <pre><code>make lizard CPP_PROJECT_DIRECTORY=$(realpath ./hello_world)\n</code></pre> <pre><code>/home/akoerner/repos/csa/test/lizard git:(master) \u2717 &gt; make lizard CPP_PROJECT_DIRECTORY=$(realpath ./hello_world)\n\n================================================\n  NLOC    CCN   token  PARAM  length  location  \n------------------------------------------------\n       3      1     12      0       3 hello@4-6@./hello_world/src/hello.cpp\n       1      1     10      1       1 main@3-3@./hello_world/hello_world.cpp\n3 file analyzed.\n==============================================================\nNLOC    Avg.NLOC  AvgCCN  Avg.token  function_cnt    file\n--------------------------------------------------------------\n      1       0.0     0.0        0.0         0     ./hello_world/include/hello.h\n      5       3.0     1.0       12.0         1     ./hello_world/src/hello.cpp\n      2       1.0     1.0       10.0         1     ./hello_world/hello_world.cpp\n\n===============================================================================================================\nNo thresholds exceeded (cyclomatic_complexity &gt; 15 or length &gt; 1000 or nloc &gt; 1000000 or parameter_count &gt; 100)\n==========================================================================================\nTotal nloc   Avg.NLOC  AvgCCN  Avg.token   Fun Cnt  Warning cnt   Fun Rt   nloc Rt\n------------------------------------------------------------------------------------------\n         8       2.0     1.0       11.0        2            0      0.00    0.00\n\n</code></pre>"},{"location":"modules/make_gadgets/","title":"make_gadgets","text":"<p>This is a collection of utility make targets that can be imported to any makefile.</p>"},{"location":"modules/make_gadgets/#usage","title":"Usage","text":"<p>Add the following import statement to the top of your Makefile:</p> <pre><code>include make_gadgets/make_gadgets.mk\n</code></pre> <p>or</p> <pre><code>include make_gadgets/docker/docker-tools.mk\n</code></pre> <p>for the docker related gadgets/targets</p>"},{"location":"modules/make_gadgets/#help-target","title":"help target","text":"<p>When imported this project provides a 'help' target. Any target preceded by '##'  will print with 'make help'</p> <p>example Makefile with help comments:</p> <pre><code>include make_gadgets/Makefile\n\nhello_world: ## This target prints \"Hello, World!\"\n    echo \"Hello, World!\"\n</code></pre> <p>now running the help target:</p> <pre><code>make help\n</code></pre> <p>yields the following output:</p> <pre><code>Usage: make &lt;target&gt;\n  hello_world  This target prints \"Hello, World!\"\n</code></pre>"},{"location":"modules/make_gadgets/#docker-targets","title":"Docker targets","text":"<p>This project also contains a Makefile with targets useful for Docker. For more information check out the provided readme:docker/README.md</p>"},{"location":"modules/make_gadgets/docker/","title":"Make Gadgets docker Makefile","text":"<p>This directory contains a Makefile with docker helper targets.  They can be imported to extend your makefile or called directly.</p>"},{"location":"modules/make_gadgets/docker/#docker-tools-makefile","title":"Docker tools Makefile","text":"<p>This directory contains a Makefile that enhance vanilla docker with make.</p> <p>The Makefile also provides several practical targets that wrap the functionality of the docker-image-cacher.sh tool provided in this project.</p> <p>To consume the provided targets/recipes from the project you can directly import the desired module to your Makefile  such as follows: </p> <pre><code>include make_gadgets/docker/docker-tools.mk\n</code></pre> <p>To include the docker-image-cacher target/recipes add the following to the top of your Makefile:</p> <pre><code>include make_gadgets/docker/docker-image-cacher.mk\n</code></pre> <p>You can directly call the provided targets/recipes by calling make directly on this directory:</p> <pre><code>cd make_gadgets/docker\nmake docker_save\n...\nmake docker_load\n...\nmake docker_orbital_cannon\n</code></pre>"},{"location":"modules/make_gadgets/docker/#docker-image-cachersh","title":"docker-image-cacher.sh","text":"<p>The docker-image-cacher.sh is a utility script for batch caching/saving and loading docker images to archives with the goal of saving network resources and quotas.</p> <p>There are several major functions this script offers namely fetching, saving, loading, and printing.  All of these will be discussed in the coming sections.</p>"},{"location":"modules/make_gadgets/docker/#image-discovery","title":"Image Discovery","text":"<p>The docker-image-cacher.sh uses a very simple strategy for discovering docker images to fetch and cache: 1. The image search path is searched and scraped recursively for Dockerfiles containing 'from ' - If no search path is provided then the docker image list is assumed from the docker local registry e.g., everything in 'docker image ls' - If the local registry is empty then only images provided in the inclusion list are added 2. All images provided in the inclusion list are appended to the found images 3. All images from the exclusion list are removed from the found images <p>Image discovery is used for fetching, caching/saving, and printing. </p>"},{"location":"modules/make_gadgets/docker/#printing","title":"Printing","text":"<p>you can call docker-image-cacher.sh with the -p or --print flag to perform a print operation.</p> <p>The print operation or action simply prints the docker image list that will be fetched and cached/saved with their respective operations.</p> <p>Printing preempts all other actions, the list of docker images will be printed and the program will exit.</p>"},{"location":"modules/make_gadgets/docker/#fetching","title":"Fetching","text":"<p>You can call docker-image-cacher.sh with the -f or --fetch flag to perform a fetch operation.</p> <p>There are two ways this can be done. The fist way provides a docker image search path as a basis to collect a list of images to fetch as in the following example:</p> <pre><code>bash docker-image-cacher.sh --docker-image-search-path \"&lt;some search path&gt;\" --fetch\n</code></pre> <p>All Dockerfiles in the search path provided will be recursively searched for the docker key word \"FROM\". Any image  that is referenced by \"FROM IMAGE:TAG\" in any Dockerfile within the search path will be fetched with docker using  the docker pull command.</p> <p>The second way to fetch docker images is to provide no search path such as follows:</p> <pre><code>bash docker-image-cacher.sh --fetch\n</code></pre> <p>This will effectively update every image already loaded into docker on your host.</p>"},{"location":"modules/make_gadgets/docker/#savingcaching","title":"Saving/Caching","text":"<p>Saving can be called in several ways.  The first way is providing a cache directory and search path:</p> <pre><code>bash docker-image-cacher.sh --docker-image-search-path \"&lt;some search path&gt;\" --docker-image-cache-directory \"&lt;cache dir to save images to&gt;\" --save\n</code></pre> <p>resulting in every discovered docker image will be saved into the default docker image cache directory as an archive  for each image. </p> <p>Another way save can be called is providing a search path but no cache directory:</p> <pre><code>bash docker-image-cacher.sh --docker-image-search-path \"&lt;some search path&gt;\" --save\n</code></pre> <p>The image archives will be saved to the default cache path.</p> <p>Another way to call save is without a search path such as follows:</p> <pre><code>bash docker-image-cacher.sh --save\n</code></pre> <p>Every image in the docker registry will be saved to disk as a tar archive into the default docker image cache directory.</p> <p>In order for save to work all docker images in the image list must exist in the docker registry. An image can be added to the registry in multiple ways: - Calling 'docker build' on a Dockerfile containing an image reference will pull it to the local registry - Calling 'docker pull ' - Using docker-image-cacher.sh with the --fetch flag to batch pull a list of images."},{"location":"modules/make_gadgets/docker/#loading","title":"Loading","text":"<p>All images that are cached as tar archives in the default docker image cache directory will be loaded into the docker registry.</p> <pre><code>bash docker-image-cacher.sh --load\n</code></pre> <p>You can also load all docker images from a specific cache directory:</p> <pre><code>bash docker-image-cacher.sh --docker-image-cache-directory \"&lt;some cache dir&gt;\" --load\n</code></pre>"},{"location":"modules/make_gadgets/docker/#help","title":"Help","text":"<p>To view more documentation on this tool you can run the help flag:</p> <pre><code>bash docker-image-cacher.sh --help\n</code></pre>"},{"location":"modules/make_gadgets/docker/#use-cases","title":"Use Cases","text":"<p>This section will give a few practical use cases for the docker-image-cacher.sh tool</p>"},{"location":"modules/make_gadgets/docker/#scrape-your-home-directory-for-docker-images-fetch-them-and-save-them","title":"Scrape your home directory for docker images, fetch them, and save them","text":"<pre><code>bash docker-image-cacher.sh -docker-image-search-path \"${HOME}\" --fetch --save\n</code></pre> <p>Your home directory must have at least one Dockerfile somewhere in the directory tree.</p>"},{"location":"modules/make_gadgets/docker/#save-all-docker-images-in-the-local-registry-to-the-default-cache-location","title":"Save all docker images in the local registry to the default cache location","text":"<pre><code>bash docker-image-cacher.sh --save\n</code></pre>"},{"location":"modules/make_gadgets/docker/#load-docker-images-from-the-default-cache-location-into-the-local-registry","title":"Load docker images from the default cache location into the local registry","text":"<pre><code>bash docker-image-cacher.sh --load\n</code></pre>"},{"location":"modules/make_gadgets/docker/#fetch-and-save-the-docker-image-ubuntulatest","title":"Fetch and save the docker image 'ubuntu:latest'","text":"<pre><code>bash docker-image-cacher.sh --save --fetch -i 'ubuntu:latest'\n</code></pre> <p>and later 'ubuntu:latest' can be loaded from disk back into the local registry with:</p> <pre><code>bash docker-image-cacher.sh --load \n</code></pre>"},{"location":"modules/make_gadgets/docker/#fetch-and-save-the-docker-image-ubuntulatest-and-alpinelatest","title":"Fetch and save the docker image 'ubuntu:latest' and 'alpine:latest'","text":"<pre><code>bash docker-image-cacher.sh --save --fetch -i 'ubuntu:latest alpine:latest'\n</code></pre> <p>and later both 'ubuntu:latest' and 'alpine:latest' can be loaded from disk back into the local registry with:</p> <pre><code>bash docker-image-cacher.sh --load \n</code></pre>"},{"location":"modules/plotlablib/","title":"Index","text":""},{"location":"modules/plotlablib/#plotlablib-is-an-interface-to-plotlabserver","title":"Plotlablib is an Interface to Plotlabserver","text":"<p>Plotlablib is a message-based interface, which allows a c++ application to connect to Plotlabserver in order to display graphs.</p>"},{"location":"modules/plotlablib/#structure","title":"Structure","text":"<p>On this level the repository is a docker and make wrapper for the actual content in the module subfolder.</p>"},{"location":"modules/plotlablib/#setup","title":"Setup","text":"<p>This repository may be used on a system, which fulfills a set of requirements adore_setup. After checkout, enter make in the top level of the repository in order to build.</p>"},{"location":"modules/plotlablib/plotlablib/","title":"Index","text":""},{"location":"modules/plotlablib/plotlablib/#plotlablib","title":"plotlablib","text":"<p>A library for the interaction with plotlabserver.</p>"},{"location":"modules/plotlablib/plotlablib/#usage","title":"Usage","text":"<ul> <li>Create a factory object:      DLR_TS::PlotLab::FigureStubFactory figureFactory;</li> <li>Create a figure object:        DLR_TS::PlotLab::FigureStubZMQ* figure = figureFactory-&gt;createFigureStub(1); //parameter is window id</li> <li>Plot a line-strip:                   figure-&gt;plot(\"#myline1\",X,Y,Z,N,\"LineColor=1,0,0;LineWidth=1\");<ul> <li>\"#myline1\" is a hashtag for the plotted line. Line can be later modified or deleted using the hashtag.</li> <li>X,Y,Z are float or double arrays, e.g. as in float X, float Y,...</li> <li>You can just leave away Z, if plotting 2d data</li> <li>N is the number of points</li> <li>\"LineColor=1,0,0;LineWidth=1\" is the option string: separate options with \";\", separate name and value with \"=\"<ul> <li>Supported options are FillColor=r,g,b; LineWidth=w; LineColor=r,g,b; LineStyle=none; PointSize=w;</li> <li>Currently points are only displayed, if the LineStyle is none </li> </ul> </li> </ul> </li> <li>Plot a polygon:                       figure-&gt;patch(\"#mypoly\",X,Y,Z,N,\"style\");</li> <li>Append data to a line-strip:          figure-&gt;append(\"#myline1\",X,Y,Z,N,\"style\");<ul> <li>Adds the supplied lines/points to the end of a existing \"#myline1\" object. If no \"#myline1\" object exists, a new one is created.</li> <li>There is a maximum number of points to a line-strip. If this number is exceeded by appending, then points are removed at the beginning of the line strip. Thus the line strip behaves like a FIFO queue.</li> </ul> </li> <li>Display text:                         figure-&gt;plotText(X,Y,\"the text\");</li> <li>Plot a texture-mapped rectangle:      figure-&gt;plotTexture(\"#mytexture\",url,x,y,z,psi,w,l)<ul> <li>url is the an url to a https or file address of a png file</li> <li>x, y, z give the coordinates of the center of the texture-mapped rectangle in the figure</li> <li>psi is the orientation of the rectangle</li> <li>w and l are widht and length of the rectangle</li> </ul> </li> <li>Clear a figure:                       figure-&gt;clear();</li> <li>Remove a single plot:                 figure-&gt;erase(\"#myline1\");</li> <li>Other commands for windows are: hide, show, hideAxis, showAxis, hideGrid, showGrid, setX/Y/ZLabel, setName, setTitle</li> <li>Manipulate the viewport of the figure: setViewPortOffsets</li> </ul>"},{"location":"modules/plotlabserver/","title":"Index","text":""},{"location":"modules/plotlabserver/#plotlab-is-yet-another-plotting-tool","title":"PlotLab is yet another plotting tool...","text":"<ul> <li>plotlabserver contains a stand-alone, system-independent c++/OpenGL application, which controls several plot windows and receives plot commands from clients.</li> </ul> <p>This project provides a docker context to build and run plotlabserver.</p>"},{"location":"modules/plotlabserver/#build-status","title":"Build Status","text":""},{"location":"modules/plotlabserver/#requirements","title":"Requirements","text":"<ul> <li>docker</li> <li>make</li> </ul>"},{"location":"modules/plotlabserver/#getting-started","title":"Getting Started","text":"<p>clone project:</p> <pre><code>git clone --recurse-submodules -j8 git@github.com:DLR-TS/plotlabserver.git\n</code></pre> <p>or if you have already cloned the project:</p> <pre><code>cd plotlabserver\ngit submodules init\ngit submodules update\n</code></pre> <ul> <li>if you do not clone with --recurse-submodules make will fail.</li> </ul> <p>To view help for available make targets run the default target:</p> <pre><code>make\n</code></pre> <p>To build and run plotlabserver run the provide \"up\" target: </p> <pre><code>make up\n</code></pre>"},{"location":"modules/plotlabserver/#display-modes","title":"Display Modes","text":"<p>The provided docker context supports three display modes: native, window_manager, headless. To change the display mode modify the DISPLAY_MODE environmental variable in the docker-compose.yaml</p>"},{"location":"modules/plotlabserver/#setting-a-display-mode","title":"Setting a display mode","text":"<p>There are two options for setting a display mode. You can modify the docker-compose.yaml</p> <pre><code>...\n    environment:\n      - DISPLAY_MODE=${DISPLAY_MODE:-native}\n      # - DISPLAY_MODE=${DISPLAY_MODE:-window_manager}\n      #- DISPLAY_MODE=${DISPLAY_MODE:-headless}\n...\n</code></pre> <p>Uncomment the desired display mode.</p> <p>You can also directly set the environmental variable before calling \"make up\":</p> <pre><code>DISPLAY_MODE=native make up\n</code></pre> <p>or </p> <pre><code>DISPLAY_MODE=window_manager make up\n</code></pre> <p>or</p> <pre><code>DISPLAY_MODE=headless make up\n</code></pre>"},{"location":"modules/plotlabserver/#display-mode-native","title":"Display Mode: native","text":"<p>plotlabserver windows will be displayed as native windows within the host system window manager (does not support video recording)</p>"},{"location":"modules/plotlabserver/#display-mode-window_manager","title":"Display Mode: window_manager","text":"<p>plotlabserver windows will be displaced within a nested i3 window manager (supports video recording)</p>"},{"location":"modules/plotlabserver/#display-mode-headless","title":"Display Mode: headless","text":"<p>plotlabserver windows will be displayed on a virtual xvfb display suitable for headless host systems (supports video recording)</p>"},{"location":"modules/plotlabserver/#display-recording","title":"Display Recording","text":"<p>The docker context provides built in display recording via ffmpeg.  This is supported in window_manager and headless  display modes. One display recording is kept at a time.  Triggering a new scenario will result in the previous  recording to be overwritten.</p>"},{"location":"modules/plotlabserver/#artifacts","title":"Artifacts","text":"<p>All build artifacts will be available at plotlabserver/build including the  plotlabserver binary.</p>"},{"location":"modules/plotlabserver/#stb","title":"STB","text":"<p>stb should be hash: 5736b15</p>"},{"location":"modules/plotlabserver/plotlabserver/","title":"Index","text":""},{"location":"modules/plotlabserver/plotlabserver/#plotlabserver","title":"plotlabserver","text":"<p>Plotlabserver is a tool for distributed, real-time visualization of scientific data. The server manages several OpenGL windows with 2d/3d axes. Clients send data and plot commands via TCP, to be visualized by the server. The server provides options to export graphs as Matlab or Python/matplotlib code.</p>"},{"location":"modules/plotlabserver/plotlabserver/#description","title":"Description:","text":"<ul> <li>compile by executing build.sh</li> <li>start the server by executing start.sh</li> <li>server will create 10 figures as initially hidden windows</li> <li>after startup, clients may connect to server and manipulate figures, see plotlablib/README.md for commands</li> </ul>"},{"location":"modules/plotlabserver/plotlabserver/#ui-window-manipulation","title":"UI window manipulation:","text":"<ul> <li>keyboard \"m\" Export Matlab file \"plotfile_#date_#time_#figno_#screenshotno.m\"</li> <li>keyboard \"p\" Export 2D-Python file \"PythonPlotfile_#date_#time_#figno_#screenshotno.py\"</li> <li>keyboard \"o\" Export 3D-Python file \"PythonPlotfile_#date_#time_#figno_#screenshotno.py\"</li> <li>keyboard \"a\" switch between projections: scaled+orthogonal vs. non-scaled+perspective (more useful for 3d)</li> <li>keyboard \"l\" enter/leave log mode</li> <li>keyboard \"1,2,3...\"\" Switch between viewing angles (for 3d)</li> <li>keyboard \"6\" Toggle visibility of axes</li> <li>keyboard \"7\" Toggle grid</li> <li>drag left mouse button: rotate viewport</li> <li>double click left mouse button: reset view</li> <li>mouse wheel: zoom</li> <li>+/- zoom with keyboard</li> <li>drag right mouse button: translate</li> </ul>"},{"location":"modules/plotlabserver/plotlabserver/#log-mode","title":"Log mode:","text":"<p>While in log mode, the position of the curser is shown in the figure. Additionally, a log file is opened in the execution folder of the plotlabserver. The following actions are available in log mode: - single click left mouse button: Write the current curser position to the log file as well as heading coming from the previously logged point - keyboard \"n\" Write a line tag to the log file to seperate different coordinate groups</p>"},{"location":"modules/plotlabserver/plotlabserver/#setup","title":"Setup:","text":"<p>To install dependencies in Ubuntu (18.04 or 20.04), try:</p> <pre><code>sudo apt-get install libzmq3-dev freeglut3-dev libcurl4-openssl-dev\n</code></pre> <p>Build and start Plotlabserver:</p> <pre><code>./build.sh\n./start.sh\n</code></pre>"},{"location":"modules/plotlabserver/plotlabserver/#license","title":"License","text":"<p>The source code and the accompanying material is licensed under the terms of the EPL v2.</p>"},{"location":"modules/plotlabserver/plotlabserver/#dependencies","title":"Dependencies","text":"<p>Plotlabserver depends on external software packages.</p>"},{"location":"modules/plotlabserver/plotlabserver/#contributing","title":"Contributing","text":"<p>Please see the contribution guidelines if you want to contribute.</p>"},{"location":"modules/plotlabserver/plotlabserver/#contributors","title":"Contributors","text":"<ul> <li>Daniel He\u00df</li> <li>Thomas Lobig</li> <li>Matthias Nichting</li> </ul>"},{"location":"modules/sumo_if_ros/","title":"Index","text":""},{"location":"modules/sumo_if_ros/#sumo_if_ros","title":"sumo_if_ros","text":"<p>A catkin package, which enables exchange of information between ROS environment and SUMO.</p>"},{"location":"modules/sumo_if_ros/#getting-started","title":"Getting Started","text":"<p>This module requires docker and make installed and configured for your user</p>"},{"location":"modules/sumo_if_ros/#building-sumo_if_ros","title":"Building sumo_if_ros","text":"<ol> <li>clone the repository with recursive submodules</li> </ol> <pre><code>git clone --recurse-submodules -j8 &lt;REPO&gt;\n</code></pre> <p>or if you have already cloned the repository:</p> <pre><code>cd sumo_if_ros\ngit submodule update --init --recursive\n</code></pre> <ol> <li>run make</li> </ol> <pre><code>cd sumo_if_ros\nmake build\n</code></pre>"},{"location":"modules/sumo_if_ros/#linting","title":"Linting","text":"<p>To lint the sumo_if_ros source code you can use the provide target:</p> <pre><code>make lint\n</code></pre>"},{"location":"modules/sumo_if_ros/#help-target","title":"help target","text":"<p>To view useful targets you can run make help:</p> <pre><code>make help\n</code></pre>"},{"location":"modules/sumo_if_ros/sumo_if_ros/","title":"Index","text":""},{"location":"modules/sumo_if_ros/sumo_if_ros/#sumo_if_ros","title":"sumo_if_ros","text":"<p>A catkin package, which enables exchange of information between ROS environment and SUMO.</p>"},{"location":"modules/v2x_if_ros_msg/","title":"Temp V2x Msgs","text":"<p>Temporary home of the v2x msgs to build up a self-contained build module</p>"},{"location":"modules/v2x_if_ros_msg/#getting-started","title":"Getting Started","text":"<p>You must have docker and make installed and configured on your system</p> <ol> <li>clone the repository with submodules:</li> </ol> <pre><code>git clone --recurse-submodules -j8 git@github.com:DLR-TS/v2x_if_ros_msg.git &amp;&amp; cd v2x_if_ros_msg\n</code></pre> <ol> <li>build v2x_if_ros_msg:</li> </ol> <pre><code>make\n</code></pre>"},{"location":"modules/v2x_if_ros_msg/#build-artifacts","title":"Build Artifacts","text":"<p>After running make on this project you get the following: 1. Build artifacts are available in v2x_if_ros_msg/build 2. Docker image available called v2x_if_ros_msg:latest  3. Within the v2x_if_ros_msg:latest image build artifacts are located at /tmp/v2x_if_ros_msg/build build artifacts will be available at: v2x_if_ros_msg/build</p> <p>Copying build artifacts from the provided docker image into the current working directory:</p> <pre><code>docker cp $(docker create --rm v2x_if_ros_msg:latest):/tmp/v2x_if_ros_msg/build .\n</code></pre> <p>Pulling in v2x_if_ros_msg build artifacts into a Dockerfile:</p> <pre><code>FROM v2x_if_ros_msg:latest AS v2x_if_ros_msg\n...\n\nCOPY --from=v2x_if_ros_msg /tmp/v2x_if_ros_msg/build .\n</code></pre>"},{"location":"modules/v2x_if_ros_msg/v2x_if_ros_msg/","title":"Index","text":"<p>Look at the README.md one level above</p>"},{"location":"modules/v2x_if_ros_msg/v2x_if_ros_msg/cam_v2/","title":"Index","text":""},{"location":"modules/v2x_if_ros_msg/v2x_if_ros_msg/cam_v2/#eclipse-adore-automated-driving-open-research-httpseclipseorgadore","title":"Eclipse ADORe, Automated Driving Open Research https://eclipse.org/adore","text":""},{"location":"modules/v2x_if_ros_msg/v2x_if_ros_msg/cam_v2/#_2","title":"Index","text":""},{"location":"modules/v2x_if_ros_msg/v2x_if_ros_msg/cam_v2/#this-program-and-the-accompanying-materials-are-made-available-under-the","title":"This program and the accompanying materials are made available under the","text":""},{"location":"modules/v2x_if_ros_msg/v2x_if_ros_msg/cam_v2/#terms-of-the-eclipse-public-license-20-which-is-available-at","title":"terms of the Eclipse Public License 2.0 which is available at","text":""},{"location":"modules/v2x_if_ros_msg/v2x_if_ros_msg/cam_v2/#httpwwweclipseorglegalepl-20","title":"http://www.eclipse.org/legal/epl-2.0.","text":""},{"location":"modules/v2x_if_ros_msg/v2x_if_ros_msg/cam_v2/#_3","title":"Index","text":""},{"location":"modules/v2x_if_ros_msg/v2x_if_ros_msg/cam_v2/#spdx-license-identifier-epl-20","title":"SPDX-License-Identifier: EPL-2.0","text":""},{"location":"modules/v2x_if_ros_msg/v2x_if_ros_msg/cam_v2/#_4","title":"Index","text":""},{"location":"modules/v2x_if_ros_msg/v2x_if_ros_msg/cam_v2/#wind-project","title":"Wind Project","text":"<p>This file belongs to the Wind project de.dlr.ts.v2x:cam_v2:1.6</p>"},{"location":"modules/v2x_if_ros_msg/v2x_if_ros_msg/denm_v2/","title":"Index","text":""},{"location":"modules/v2x_if_ros_msg/v2x_if_ros_msg/denm_v2/#eclipse-adore-automated-driving-open-research-httpseclipseorgadore","title":"Eclipse ADORe, Automated Driving Open Research https://eclipse.org/adore","text":""},{"location":"modules/v2x_if_ros_msg/v2x_if_ros_msg/denm_v2/#_2","title":"Index","text":""},{"location":"modules/v2x_if_ros_msg/v2x_if_ros_msg/denm_v2/#this-program-and-the-accompanying-materials-are-made-available-under-the","title":"This program and the accompanying materials are made available under the","text":""},{"location":"modules/v2x_if_ros_msg/v2x_if_ros_msg/denm_v2/#terms-of-the-eclipse-public-license-20-which-is-available-at","title":"terms of the Eclipse Public License 2.0 which is available at","text":""},{"location":"modules/v2x_if_ros_msg/v2x_if_ros_msg/denm_v2/#httpwwweclipseorglegalepl-20","title":"http://www.eclipse.org/legal/epl-2.0.","text":""},{"location":"modules/v2x_if_ros_msg/v2x_if_ros_msg/denm_v2/#_3","title":"Index","text":""},{"location":"modules/v2x_if_ros_msg/v2x_if_ros_msg/denm_v2/#spdx-license-identifier-epl-20","title":"SPDX-License-Identifier: EPL-2.0","text":""},{"location":"modules/v2x_if_ros_msg/v2x_if_ros_msg/denm_v2/#_4","title":"Index","text":""},{"location":"modules/v2x_if_ros_msg/v2x_if_ros_msg/denm_v2/#wind-project","title":"Wind Project","text":"<p>This file belongs to the Wind project de.dlr.ts.v2x:denm_v2:1.5</p>"},{"location":"modules/v2x_if_ros_msg/v2x_if_ros_msg/dsrc_v2/","title":"Index","text":""},{"location":"modules/v2x_if_ros_msg/v2x_if_ros_msg/dsrc_v2/#eclipse-adore-automated-driving-open-research-httpseclipseorgadore","title":"Eclipse ADORe, Automated Driving Open Research https://eclipse.org/adore","text":""},{"location":"modules/v2x_if_ros_msg/v2x_if_ros_msg/dsrc_v2/#_2","title":"Index","text":""},{"location":"modules/v2x_if_ros_msg/v2x_if_ros_msg/dsrc_v2/#this-program-and-the-accompanying-materials-are-made-available-under-the","title":"This program and the accompanying materials are made available under the","text":""},{"location":"modules/v2x_if_ros_msg/v2x_if_ros_msg/dsrc_v2/#terms-of-the-eclipse-public-license-20-which-is-available-at","title":"terms of the Eclipse Public License 2.0 which is available at","text":""},{"location":"modules/v2x_if_ros_msg/v2x_if_ros_msg/dsrc_v2/#httpwwweclipseorglegalepl-20","title":"http://www.eclipse.org/legal/epl-2.0.","text":""},{"location":"modules/v2x_if_ros_msg/v2x_if_ros_msg/dsrc_v2/#_3","title":"Index","text":""},{"location":"modules/v2x_if_ros_msg/v2x_if_ros_msg/dsrc_v2/#spdx-license-identifier-epl-20","title":"SPDX-License-Identifier: EPL-2.0","text":""},{"location":"modules/v2x_if_ros_msg/v2x_if_ros_msg/dsrc_v2/#_4","title":"Index","text":""},{"location":"modules/v2x_if_ros_msg/v2x_if_ros_msg/dsrc_v2/#wind-project","title":"Wind Project","text":"<p>This file belongs to the Wind project de.dlr.ts.v2x:dsrc_v2:3.0</p>"},{"location":"modules/v2x_if_ros_msg/v2x_if_ros_msg/its_container_v2/","title":"Index","text":""},{"location":"modules/v2x_if_ros_msg/v2x_if_ros_msg/its_container_v2/#eclipse-adore-automated-driving-open-research-httpseclipseorgadore","title":"Eclipse ADORe, Automated Driving Open Research https://eclipse.org/adore","text":""},{"location":"modules/v2x_if_ros_msg/v2x_if_ros_msg/its_container_v2/#_2","title":"Index","text":""},{"location":"modules/v2x_if_ros_msg/v2x_if_ros_msg/its_container_v2/#this-program-and-the-accompanying-materials-are-made-available-under-the","title":"This program and the accompanying materials are made available under the","text":""},{"location":"modules/v2x_if_ros_msg/v2x_if_ros_msg/its_container_v2/#terms-of-the-eclipse-public-license-20-which-is-available-at","title":"terms of the Eclipse Public License 2.0 which is available at","text":""},{"location":"modules/v2x_if_ros_msg/v2x_if_ros_msg/its_container_v2/#httpwwweclipseorglegalepl-20","title":"http://www.eclipse.org/legal/epl-2.0.","text":""},{"location":"modules/v2x_if_ros_msg/v2x_if_ros_msg/its_container_v2/#_3","title":"Index","text":""},{"location":"modules/v2x_if_ros_msg/v2x_if_ros_msg/its_container_v2/#spdx-license-identifier-epl-20","title":"SPDX-License-Identifier: EPL-2.0","text":""},{"location":"modules/v2x_if_ros_msg/v2x_if_ros_msg/its_container_v2/#_4","title":"Index","text":""},{"location":"modules/v2x_if_ros_msg/v2x_if_ros_msg/its_container_v2/#wind-project","title":"Wind Project","text":"<p>This file belongs to the Wind project de.dlr.ts.v2x:its_container_v2:1.6</p>"},{"location":"setup/first_scenario/","title":"First scenario","text":""},{"location":"setup/first_scenario/#running-your-first-scenario","title":"Running Your First Scenario","text":""},{"location":"setup/getting_started/","title":"Getting Started","text":""},{"location":"setup/getting_started/#getting-started","title":"Getting Started","text":"<p>This guide will help you get your system set up and configure to run ADORe.</p>"},{"location":"setup/getting_started/#getting-started-with-adore","title":"Getting started with ADORe","text":"<ol> <li> <p>First review the System Requirements \ud83d\udd17. </p> </li> <li> <p>Next review the Prerequisites \ud83d\udd17 </p> </li> <li> <p>Clone the repository: </p> <p><code>bash git clone git@github.com:eclipse/adore.git</code></p> </li> <li> <p>Initialize and update the submodules:</p> <p><code>bash cd adore git submodule update --init</code></p> <p>\u26a0\ufe0f WARNING: Failing to update the submodules will result in build failures!</p> </li> <li> <p>Build ADORe and ADORe CLI</p> </li> </ol> <p>\u2139\ufe0f INFO: It is recommended doing a first build of ADORe connected to hard line ethernet and not WIFI until initial docker and APT caches are established on your system.</p> <p>After cloning ADORe and satisfying all system prerequisites you can build/run the ADORe CLI context. To do this navigate to the root of the ADORe directory and run the following command:</p> <pre><code>make cli\n</code></pre> <p>For more informant please visit the ADORe CLI \ud83d\udd17 documentation.</p> <p>\u2705 SUCCESS: If you are greeted with the following ADORe CLI car then you have successfully setup ADORe:</p> <pre><code>            ____ \n         __/  |_\\__\n        |           -. \n  ......'-(_)---(_)--' \n</code></pre>"},{"location":"setup/installing_docker/","title":"Installing Docker","text":"<p>The ADORe build system sometimes uses experimental features of docker.  For this reason it is important to have a recent version of docker installed.  Using \"apt-get\" or \"apt\" to install Docker is not sufficient. Software packages within the Ubuntu central repositories are always very old.</p> <p>\u26a0\ufe0f  WARNING: ADORe depends on docker compose &gt;= v2. If you do not have docker compose &gt;= v2 installed your build will fail. The command line tool <code>docker-compose</code> was renamed to <code>docker compose</code>. Install the latest docker to resolve this issue. For more information view the following stack overflow issue: https://stackoverflow.com/questions/66514436/difference-between-docker-compose-and-docker-compose \ud83d\udd17</p>"},{"location":"setup/installing_docker/#installing-docker-ubuntu-2004-and-2204","title":"Installing Docker: Ubuntu 20.04 and 22.04","text":"<p>To install the latest version of docker in Ubuntu 20.04 and 22.04 you can follow the official Docker document at: https://docs.docker.com/engine/install/ubuntu/ \ud83d\udd17</p> <p>Alternatively, ADORe provides a shell script that you can use to install the latest Docker. </p> <pre><code>curl -sSL https://raw.githubusercontent.com/DLR-TS/adore_tools/master/tools/install_docker.sh | bash -\n</code></pre> <p>Follow the prompts until the installation completes. Once complete you should be greeted with something such as this:</p> <pre><code>Hello from Docker!\nThis message shows that your installation appears to be working correctly.\n</code></pre> <p>\u26a0\ufe0f  WARNING: As a general rule you should never run shell scripts from untrusted sources. </p> <p>\u2139\ufe0f INFO: After installing Docker you may need to log out and log back in to make group changes take effect.</p>"},{"location":"setup/installing_docker/#verifying-your-docker-group","title":"Verifying your Docker group","text":"<p>In order for you to be able to run any docker commands your current user must be a member of the docker group. This occurs during installation but will not  take effect until you log out and log back in again. To verify you are a member of the docker group run: <code>id | sed \"s|,|\\n|g\" | grep docker</code></p> <p>Which should yield something similar to:</p> <pre><code>998(docker)\n</code></pre>"},{"location":"setup/installing_docker/#verifying-your-docker-installation","title":"Verifying your docker installation","text":"<p>At any time you can verify your docker installation by running the docker hello world image with the following:</p> <pre><code>docker run hello-world\n</code></pre> <p>Which will yield:</p> <pre><code>Hello from Docker!\nThis message shows that your installation appears to be working correctly.\n</code></pre> <p>\u2139\ufe0f INFO: After installing Docker you may need to log out and log back in to make group changes take effect.</p> <p>\u2139\ufe0f INFO: The ADORe build system depends on <code>docker compose</code>. At some point the <code>docker compose</code> tool was renamed from <code>docker-compose</code> to <code>docker compose</code>. If you have an older version of docker you will receive an error. Please update your Docker engine.</p>"},{"location":"setup/prerequisites/","title":"ADORe Prerequisites","text":"<p>ADORe requires a recent version of make and Docker on your system. ADORe is officially supported in Ubuntu 20.04 and 22.04. The following document applies to that.</p>"},{"location":"setup/prerequisites/#check-your-system","title":"Check your system","text":"<p>Check to make sure you have a supported system by running the following command:</p> <pre><code>cat /etc/os-release | grep \"VERSION=\" | cut -d\"=\" -f2\n</code></pre> <p>should yield something such as the following:</p> <pre><code>\"22.04.2 LTS (Jammy Jellyfish)\"\n</code></pre> <p>In principle, any x86 linux operating system supporting Docker and Make will run ADORe however installation steps for all the tooling will differ. </p>"},{"location":"setup/prerequisites/#installing-make","title":"Installing make","text":"<pre><code>sudo apt-get install -y make\n</code></pre>"},{"location":"setup/prerequisites/#installing-docker","title":"Installing Docker","text":"<p>Review the Installing Docker \ud83d\udd17 </p>"},{"location":"setup/prerequisites/#checking-your-free-space","title":"Checking your free space","text":"<p>ADORe and the associated tools require a significant amount of transient storage It is recommended that you have a minimum of 20 GB of free space to work with ADORe. Optimally, you should have at least 40 GB. To check the amount of free space on your system you can run the following command:</p> <pre><code>df -h . | awk 'NR==2 {print \"Available Free Space:\", $4}'\n</code></pre>"},{"location":"setup/prerequisites/#time","title":"Time","text":"<p>On the first build of ADORe you will need ~15-20 minutes to download and clone  all the sources, dependencies, and context.  Subsequent builds are very quick  after requisite caches (apt, docker) have been established.</p> <p>\u2139\ufe0f INFO: Build and fetch times can very greatly depending on system configuration and network.</p>"},{"location":"setup/prerequisites/#conclusion","title":"Conclusion","text":"<p>Once you have to correct operating system, adequate free space, as well as, have make and docker installed you are good to proceed with using ADORe. </p>"},{"location":"setup/system_requirements/","title":"System Requirements","text":""},{"location":"setup/system_requirements/#system-requirements","title":"System Requirements","text":"<p>The following section will detail the recommended hardware/system configuration, as well as, required software configuration in order to build and run ADORe and it's components.</p>"},{"location":"setup/system_requirements/#minimum-system-configurations","title":"Minimum System Configurations","text":"<p>CPU: </p> <ul> <li>Intel CORE i7 7700K or equivalent/better</li> <li>The more cores you have, the more trajectory planners you can run in    parallel.</li> <li>No specific graphics card is required as everything (except plotting) runs on    the CPU</li> <li>Any x86 base equivalent processor (ARM support is planned)</li> </ul> <p>RAM: </p> <p>Min 8GB for execution. Compilation process is faster with 16+GB</p> <p>HD storage:</p> <ul> <li>at least 2.5 GB to clone the repository</li> <li>at least 15 GB to build all necessary docker context</li> </ul> <p>Operating system: </p> <ul> <li>Anything that supports newer docker versions. </li> <li>Recommended: Ubuntu 20.04 or 22.04</li> </ul> <p>Network:</p> <p>A reliable network with high throughput and low latency. Initial    build can take a significant amount of time to pull all necessary dependencies   from apt and docker. A poor connection will result in non-deterministic build    failures. </p> <p>\u26a0\ufe0f WARNING: If you have a bad internet connection you may experience build failures  involving APT cacher ng. Try running 'make cli' or 'make build' again. please visit the Problems and Solutions documentation for more information.</p> <p>It is definitely possible to run and compile ADORe and components of adore on less capable hardware however for the best experience equal to or better then the previous configuration is recommended. </p>"},{"location":"setup/system_requirements/#software-requirements","title":"Software Requirements","text":"<ul> <li>Docker \ud83d\udd17 v20.10.17 or greater and docker compose v2.6.0 or greater. To install   the latest docker and docker compose run the following command:</li> </ul> <pre><code>curl -sSL https://raw.githubusercontent.com/DLR-TS/adore_tools/master/tools/install_docker.sh | bash`. \n</code></pre> <p>For more information review the official docker documentation: https://docs.docker.com/engine/install/ubuntu/ \ud83d\udd17</p> <p>\u26a0\ufe0f WARNING: As a general rule you should never run shell scripts from untrusted sources. </p> <ul> <li>GNU Make \ud83d\udd17 is the backbone of the ADORe build system and is also required.</li> </ul>"},{"location":"system_and_development/CONTRIBUTING/","title":"CONTRIBUTING","text":""},{"location":"system_and_development/CONTRIBUTING/#we-welcome-your-contribution","title":"We welcome your contribution!","text":"<p>Currently ADORe is a small project; please feel free to  contact \ud83d\udd17 us with any questions or feedback. If you have ideas for extensions or want to change or fix anything:</p> <ul> <li>Open an issue \ud83d\udd17</li> <li>Create a fork \ud83d\udd17</li> <li>Create a pull request \ud83d\udd17 and/or     sponsor a feature on ADORe directly or any of the     ecosystem submodules/projects \ud83d\udd17</li> <li>Get Help</li> </ul>"},{"location":"system_and_development/adore_cli/","title":"Adore cli","text":""},{"location":"system_and_development/adore_cli/#adore-command-line-interface-cli","title":"ADORe command line interface (CLI)","text":"<p>The ADORe CLI is a docker runtime context that provides a complete set of tools for execution and development within adore. For more information on this tool please visit https://github.com/DLR-TS/adore_cli</p> <p>The ADORe CLI context provides the following features:  * Execution environment for all ADORe related binaries  * A pre-generated catkin workspace located at adore/catkin_workspace * Reuse of previously generated binaries and build artifacts. All build  artifacts generated previously with make build can be executed in this  environment * Headless, native or windowed plotlab server running as a docker compose  service.  The display mode for plotlab server can be configured with the  docker-compose.yaml. For more information on plotlab server please review the README.md provided by that module at plotlabserver/README.md server can be configured  * ros master running as a docker compose service * All ROS tools preinstalled * some basic development and debugging tools * ZSH</p>"},{"location":"system_and_development/adore_cli/#adore-cli-usage","title":"ADORe CLI Usage","text":"<p>Change directory to the root of the ADORe project and run:</p> <pre><code>make cli\n</code></pre> <p>On first run of the ADORe CLI the system will be built including all core modules. Initial build can take 10-15 minutes depending on system and network. </p> <p>Once the ADORe CLI context builds and starts you will be presented with a  zsh shell context:</p> <pre><code>Welcome to the ADORe Development CLI Ubuntu 20.04.6 LTS (GNU/Linux 5.19.0-45-generic x86_64)\n\n            ____ \n         __/  |_\\__\n        |           -. \n  ......'-(_)---(_)--' \n\n  Type 'help' for more information.\n\n  Waiting for plotlab server ... plotlab server ready \n\n  Vehicle environment set to: Development\n\nADORe CLI: adore git:(main)  (0)&gt;  \n</code></pre> <p>\u26a0 WARNING: Any changes to the adore cli context require manually invoking a build for it to take effect!  The ADORE CLI is only built on first invocation of 'make cli'</p> <p>This will build all necessary ADORe components and launch a docker context.</p>"},{"location":"system_and_development/adore_cli/#how-do-i-know-if-i-am-in-the-adore-cli-context","title":"How do I know if I am in the ADORe CLI context?","text":"<ul> <li>If you are in the ADORe CLI context you should have a shell prompt similar to   the following: <code>ADORe CLI: adore git:(master)  (0)&gt;</code></li> <li>you can also check your current user with:</li> </ul> <pre><code>whoami\n</code></pre> <p>should report:</p> <pre><code>adore-cli\n</code></pre>"},{"location":"system_and_development/adore_cli/#persistence","title":"Persistence","text":"<p>When running the ADORe CLI the adore source directory is mounted as a volume. It will be mounted with the same path as the parent context. Any changes made  in the adore source tree will persist on the host/parent file system.</p>"},{"location":"system_and_development/anonymous_cloning/","title":"Anonymous cloning","text":""},{"location":"system_and_development/anonymous_cloning/#anonymous-cloning","title":"Anonymous Cloning","text":"<p>In order to make development more friendly nearly all git submodules are  configured to use git over ssh via the .gitmodules. The downside of this is that github requires account keys to be configured to in order to clone the repository. If you attempt to clone without configuring your account keys you will receive  the following error:</p> <pre><code>git clone git@github.com:eclipse/adore.git\nCloning into 'adore'...\nThe authenticity of host 'github.com (140.82.121.3)' can't be established.\nECDSA key fingerprint is SHA256:p2QAMXNIC1TJYWeIOttrVc98/R1BUFWu3/LiyKgUfQM.\nAre you sure you want to continue connecting (yes/no/[fingerprint])? yes\nWarning: Permanently added 'github.com,140.82.121.3' (ECDSA) to the list of known hosts.\ngit@github.com: Permission denied (publickey).\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\n</code></pre>"},{"location":"system_and_development/anonymous_cloning/#anonymous-cloning-over-https","title":"Anonymous Cloning Over HTTPS","text":"<p>You can configure git to exclusively use https. This can be done with the  following commands:</p> <pre><code>git config --global url.\"https://github.com/\".insteadOf git@github.com:\ngit config --global url.\"https://\".insteadOf git://\n</code></pre> <p>Next, you can clone the repository as normal except use https:</p> <pre><code>git clone -recurse-submodules -j$(nproc) https://github.com/eclipse/adore.git\n</code></pre>"},{"location":"system_and_development/build_system/","title":"ADORe Build System","text":"<p>The ADORe build system is a docker build and runtime  environment for ADORe.</p>"},{"location":"system_and_development/build_system/#background","title":"Background","text":"<p>Although ADORe is primarily centered around ROS there is also stand-alone  components in a conglomeration of technologies such as python, C++ and others. Each component could have their own respective build and run steps. The primary  aim of the build system is to normalize complex build processes, as well as,  provide a containerized runtime for these processes with a focus of  configuration management of dependencies and software reuse.</p>"},{"location":"system_and_development/build_system/#build-interface-normalization","title":"Build interface normalization","text":"<p>The ADORe build system aims to provide per module predictable building and  testing interfaces via GNU Make such as: 'make build', 'make test, and more.</p> <p>GNU Make is not a new tool however it is stable and familiar to many developers. For this reason it was selected as the centralized \"glue\" for the ADORe build system. GNU Make offers \"documentation-as-code\" for ADORe capturing complex  build, testing, and execution processes, steps, and commands into a single  location. To discover the capabilities of a given module, or what a module can  do, simple inspect the provided Makefile. It is up to the developer of a module  to provide interesting or relevant targets for the project or module. At minimum 'make build', 'make test', and 'make clean' should be provided by a module.  Review the modules section for more detail on what constitutes a  module.</p>"},{"location":"system_and_development/build_system/#dependency-configuration-management","title":"Dependency configuration management","text":"<p>In a standard Dockerfile it can be difficult to manage or version system  dependencies because system dependencies are globed together often on one line.  The following is a typical example that could be  found in a Dockerfile for  installing system dependencies following docker \"best practices\":</p> <pre><code>...\nRUN apt-get update &amp;&amp; apt-get install -y a b c &amp;&amp; \\\n    rm -rf /var/lib/apt/lists/*\n...\n</code></pre> <p>The problem with this is dependencies tend to change while the build procedure  may not. In this previous example the dependencies namely a, b, and c are all  grouped on one line. This makes updating, versioning, tracking/documenting \\ (where did the dependency come from or what needs it), and composing dependencies difficult.</p> <p>The next example used throughout the ADORe build system adds complexity but also  has a number of distinct benefits:</p> <pre><code>...\nARG REQUIREMENTS_FILE\n...\nRUN apt-get update &amp;&amp; \\\n    apt-get install --no-install-recommends -y $(sed '/^#/d' ${REQUIREMENTS_FILE} | sed '/^$/d') &amp;&amp; \\\n    rm -rf /var/lib/apt/lists/*\n...\n</code></pre> <p>The previous example provides the following benefits:</p> <ul> <li>Dependencies can be tracked in an independent file such as in the case with adore_if_ros_msg: requirements.adore_if_ros_msg.ubuntu20.04.system If the base system is changed or upgraded then all that needs to be updated is  the dependency file.</li> <li>There is one dependency per line such as the following example for g++</li> <li>Discovering dependencies within the system is easy With the following shell command run on the top level of the ADORe project all dependencies within the project can be discovered: <code>find -name \"requirements.*.ubuntu20.04.system\"</code></li> <li>Composition of dependencies becomes trivial</li> <li>Building up new docker contexts that pull in dependencies from other modules is  possible because the dependency files are separate</li> <li>Using sed to filter the dependency file allows the use of \"#\" comments within  the file. This is useful to documenting/commenting and managing individual  dependencies.</li> </ul> <p>In general there will be a <code>files/requirements.&lt;module&gt;.&lt;base system&gt;.system</code>  file that contains all necessary dependencies for that module for example:  \"requirements.adore_if_ros_msg.ubuntu20.04.system\" which is the system  dependency file for adore_if_ros_msg.  Furthermore, the system dependency files  can be segregated into separate files based off of life-cycle context such as  build dependencies and run dependencies. This is true for modules such as  libadore which has a build requirements file and a runtime requirements file.  Although, it is not strictly essential to separate build and runtime system  dependencies it makes management and composition of dependencies easier with the effect of lowering overall docker context sizes.</p>"},{"location":"system_and_development/build_system/#modules","title":"Modules","text":"<p>ADORe relies heavily on git submodules for code reuse and boundaries. </p> <ul> <li>In general every directory is a module and potentially a stand-alone project</li> <li>Every module will provide a Makefile and a Dockerfile </li> <li>Every module will have at minimum a 'build' and 'clean' make target</li> </ul>"},{"location":"system_and_development/build_system/#artifacts","title":"Artifacts","text":"<p>Every module will generate artifacts in some form during their respective life-cycles. This section will detail the possible artifacts.</p>"},{"location":"system_and_development/build_system/#build-artifacts","title":"Build artifacts","text":"<p>Every module that produces build artifacts follows the same basic pattern. All  build artifacts generated by 'make build' will generate a build directory with  the following path: <code>&lt;repository name&gt;/&lt;module name&gt;/build</code> This could contain binaries, cmake install prefix, headers, Debian packages  et cetera. </p>"},{"location":"system_and_development/build_system/#docker-images","title":"Docker images","text":"<p>In general every module will produce at least a build docker image. If a module requires a runtime context or other contexts these will be generated as well. For example on the module libadore. produces the following images:</p> <p></p> <p>In the case of libadore there is a docker context for build which contains only the build artifacts, a test context which can be used to execute unit tests and the main context. What docker images/contexts are produced with make build are dependent on the module needs.</p> <p>The internal file system layout for each module will be the same and follow the same pattern.  All project files will be placed in /tmp/ within the docker context. <p>In the case of project containing ROS packages the structure will be:  <code>/tmp/&lt;module name&gt;/&lt;module name&gt;</code> where the first directory contains the docker context with Makefile and requirements file and the second directory with the  same module name will be a standard ROS package with a CMakeLists.txt, package.xml and any other necessary files. Running 'ls' on the /tmp/libadore  directory within the libadore build context yields this familiar structure: </p>"},{"location":"system_and_development/build_system/#log-artifacts","title":"Log artifacts","text":"<p>Some modules produce log output during various life cycle phases for example during build, test, or execution. This log output will be placed in the  following path: <code>&lt;repository name&gt;/.log/</code>. Which logs a module generates is wholly dependent on the module in question. For more information on this please refer to individual documentation within  a module.</p>"},{"location":"system_and_development/build_system/#module-anatomy","title":"Module anatomy","text":"<p>The following section will detail the basic anatomy of a module. At minimum  every module will have a Makefile and a Dockerfile</p>"},{"location":"system_and_development/build_system/#makefile","title":"Makefile","text":"<p>At minimum every module should have a Makefile with 'build' and clean 'targets' defined. The Makefile provides \"documentation-as-code\" so if you are wondering what capabilities a module offers the first place to look is the Makefile. </p> <p>The makefile also provides important environmental variables for docker build and docker run such as a docker tag and potentially other important  environmental variables relevant to the module.</p> <p>In general every module should provide a <code>make help</code> target to guild users on  module capabilities. The 'help' target used throughout the ADORe ecosystem is a spin on the following github gist: https://gist.github.com/prwhite/8168133 and is  provided by the make_gadgets project at: https://github.com/DLR-TS/make_gadgets. Any Makefile that has <code>include make_gadgets/make_gadgets.mk</code> will have a  <code>make help</code> target. </p> <p>Any target or recipe that has two hash symbols such as the following example Makefile:</p> <pre><code>include make_gadgets/make_gadgets.mk\n\n.PHONY: test_target\ntest_target: ## this is a test target\n        echo \"Hello, World!\"\n</code></pre> <p>will output the comment and target name with the invocation of <code>make help</code>.  Calling <code>make help</code> on the previous example Makefile would then yield the  following:</p> <p></p> <p>As can be seen in the previous image the make_gadgets project also provides another very important recipe/target that is used throughout the ADORe  ecosystem specifically the \"get_sanitized_branch_name\". Calling this target  returns the branch name or hash that has been sanitized such that it can be  used as a docker image tag. This will be further detailed in a later section.</p> <p>For more information on how the help target works please review the  documentation for https://github.com/DLR-TS/make_gadgets or the gist at  https://gist.github.com/prwhite/8168133</p> <p>The Makefile provides the primary means to interact with a module directly by  navigating to a module and running make commands on the module. </p>"},{"location":"system_and_development/build_system/#dockerfile","title":"Dockerfile","text":"<p>The Dockerfile is pretty self-explanatory and in general every module will have a Dockerfile in its root. More dockerfiles may be provided by a module if  necessary depending if the module also requires runtime context. If there are many docker files within a module then they can be organized in a subdirectory  called 'docker'. GNU Make is used primarily to invoke <code>docker</code> or  <code>docker compose</code> within ADORe.</p>"},{"location":"system_and_development/build_system/#interface-makefile-mk","title":"Interface makefile .mk <p>Many modules within ADORe have two makefiles namely 'Makefile' and  '.mk'. The first makefile ('Makefile') allows make commands to be run directly on the module by navigating to the module directory in a shell and running for example <code>make build</code> or <code>make clean</code>.  <p>The second makefile having the same name of the module itself (for example in  adore_if_ros_msg: adore_if_ros_msg.mk) acts as the external interface for the  module.  The basic question for this makefile is what behavior, context, and  environmental variables should be exported from the module. This makefile will include the following:</p> <ul> <li>Important environmental variables for the module (such as docker tag) </li> <li>All the necessary make includes (does the module depend on other modules?)</li> <li>All targets that should be externally visible to downstream projects</li> </ul> <p>The self-named makefile included in each module is the external interface for the module. </p> <p>Take this minimal example makefile which includes adore_if_ros_msg.mk:</p> <pre><code>include make_gadgets/make_gadgets.mk\ninclude adore_if_ros_msg/adore_if_ros_msg.mk\n\n.PHONY: test_target\ntest_target: ## this is a test target\n        echo \"Hello, World!\"\n</code></pre> <p>By including adore_if_ros_msg.mk all of the exported targets are now available. Calling <code>make help</code> now on this example Makefile yields the following output:</p> <p></p> <p>This allows composition of modules.</p> <p>The self-named makefile previous discussed also provides a number of important  dynamic environmental variables which follow the basic form: </p> <pre><code>&lt;module name&gt;_PROJECT\n&lt;module name&gt;_MAKEFILE_PATH\n&lt;module name&gt;_SUBMODULES_PATH\n&lt;module name&gt;_TAG\n&lt;module name&gt;_IMAGE\n</code></pre> <p>For example in the module adore_if_ros_msg the following environmental variables are provided:</p> <pre><code>ADORE_IF_ROS_MSG_IMAGE= ${ADORE_IF_ROS_MSG_PROJECT}:${ADORE_IF_ROS_MSG_TAG}\nADORE_IF_ROS_MSG_MAKEFILE_PATH= /home/akoerner/repos/csa/github.com/eclipse/test/adore_if_ros_msg\nADORE_IF_ROS_MSG_PROJECT= adore_if_ros_msg\nADORE_IF_ROS_MSG_SUBMODULES_PATH= /home/akoerner/repos/csa/github.com/eclipse/test/adore_if_ros_msg\nADORE_IF_ROS_MSG_TAG= master\n</code></pre> <p>The environmental variables that a module provides is up to the module author  but the previously detailed variables are common.  The most important variable  being the <code>&lt;module name&gt;_IMAGE</code>, <code>&lt;module name&gt;_PROJECT</code>, and  <code>&lt;module name&gt;_TAG</code> variables which are all relevant for docker image building  and tagging. </p>","text":""},{"location":"system_and_development/build_system/#files-directory","title":"'files' directory <p>By convention most modules include a 'files' directory; this files directory contains any context that should be included during build using the docker  <code>COPY</code> key word such as entry point shell scripts, requirements files et cetera.</p>","text":""},{"location":"system_and_development/build_system/#module-composition","title":"Module Composition","text":"<p>The ADORe build system offers two methods of module composition which will be detailed below. </p>"},{"location":"system_and_development/build_system/#hierarchic-composition","title":"Hierarchic Composition <p>In general a module only has visibility into the contents within said module. This allows modules to be cloned and operated on in complete isolation to parent context. This is useful for building up complex CI processes. The following image illustrates the concept:</p> <p></p> <p>A give module will have all necessary dependencies within it's tree. Any node within the tree can be cloned, built and tested in isolation. This requires recursive cloning; here is an example of adore_if_ros_msg being cloned, built and tested: </p> <pre><code>git clone git clone --recursive -j8 git@github.com:DLR-TS/adore_if_ros_msg.git\ncd adore_if_ros_msg\nmake build\nmake test\n</code></pre> <p>Hierarchic composition has a number of benefits but also carries significant drawbacks. Development can be cumbersome because every reference to a module within a project then needs to be updated with any change. </p>","text":""},{"location":"system_and_development/build_system/#open-composition","title":"Open Composition <p>To address the previously discussed drawback of hierarchic module composition  open module composition is also supported within the ADORe ecosystem. This allows all modules to be placed in a flat directory structure. The pitfall being that all required modules must be present in this directory structure otherwise Make operations will fail.</p> <p>The following image illustrates the concept of open module composition:</p> <p></p> <p>Open module composition is achieved by introducing the <code>SUBMODULES_PATH</code> environmental variable. This must be defined either by the current environment or by a parent Makefile when invoking a make action on a module. </p> <p>If the <code>SUBMODULES_PATH</code> variable is not defined and a give module has not been recursively cloned running any make target on a submodule/module will yield the following error:</p> <pre><code>adore_if_ros_msg(e9019d5) (2)&gt; make help \nINFO: To clone submodules use: 'git submodule update --init --recursive'\nINFO: To specify alternative path for submodules use: SUBMODULES_PATH=\"&lt;path to submodules&gt;\" make build'\nINFO: Default submodule path is: /home/akoerner/repos/csa/github.com/eclipse/adore/adore_if_ros_msg'\nadore_if_ros_msg.mk:21: *** \"ERROR: /home/akoerner/repos/csa/github.com/eclipse/adore/adore_if_ros_msg/make_gadgets \ndoes not exist. Did you clone the submodules?\".  Stop.\n</code></pre> <p>To avoid this error the <code>SUBMODULES_PATH</code> environmental variable has to be sourced. This can be done in one of two ways.</p> <ol> <li>source the provided adore.env file into your interactive shell. CD to the root of the adore project and run:</li> </ol> <pre><code>source adore.env\n</code></pre> <p>This will define and export the <code>SUBMODULES_PATH</code> environmental variable for you. After this you can go to any module and invoke make commands such as <code>make build</code> and <code>make clean</code></p> <ol> <li>The second option is to simply provide the <code>SUBMODULES_PATH</code> environmental variable directly when invoking make such as follows:</li> </ol> <pre><code>cd adore_if_ros_msg\nSUBMODULES_PATH=\"$(realpath ..)\" make build\n</code></pre>","text":""},{"location":"system_and_development/building/","title":"Building","text":"<p>This is a general guide on how to build components within ADORe</p> <p>For a deep dive into the ADORe build system see: [system_and_development/build_system.md]</p>"},{"location":"system_and_development/building/#building-components-within-adore","title":"Building components within ADORe","text":"<p>In general every module in ADORe offers the following general build related make targets/recipes: <code>make help</code>, <code>make build</code>, <code>make clean</code>, and <code>make test</code>. To discover what targets/recipes are provided by a given module navigate to the  module and run: <code>make help</code></p>"},{"location":"system_and_development/building/#adore-core","title":"ADORe Core","text":"<p>On first invocation all of the ADORe CLI with <code>make cli</code> only core modules  are built. If you are using other modules you may need to manually invoke a  build or use the provide <code>make build_all</code> target. </p> :warning: WARNING Only core ADORe modules are build with <code>make cli</code>. If you are seeing ros node errors when running roslaunch try the <code>make build_all</code> target provided by adore or manually build the module you are trying to use. <p>Each module provides a Makefile and docker context for build. You can build the  core ADORe modules by navigating to the ADORe project root and running:</p> <pre><code>cd adore\nmake build\n</code></pre> <p>By default only core modules are built to save time. To build all ADORe modules  you can run the provided target:</p> <pre><code>make build_all\n</code></pre>"},{"location":"system_and_development/building/#building_1","title":"Building","text":"<p>You can manually invoke rebuilding of any ADORe module if it supports it. 1. First you have to set the SUBMODULES_PATH environmental variable. - Navigate to the root of the ADORe project and run: <code>export SUBMODULES_PATH=$(pwd)</code></p> <p>or</p> <ul> <li>Source the provided environment file by navigating to the root of the ADORe   project and running: <code>source adore.env</code></li> <li>Now you can navigate to any module and manually invoke a build</li> </ul> <pre><code>cd adore_if_ros_msg\nmake build\n</code></pre> <pre><code>cd sumo_if_ros\nmake build\n</code></pre>"},{"location":"system_and_development/building/#build_fast-targets","title":"build_fast targets","text":"<p>Several modules offer a \"build_fast\" target. When this target is invoked the module is only built if it has not already been built i.e., if you run <code>docker image ls</code> and see your module then a build will not occur. This is to save on build time and cache invalidation. </p> <p>For theses modules such as the adore_cli and plotlabserver for example you can  manually invoke <code>make build</code> or if you are on the root of the ADORe project <code>make build_adore_cli</code> and <code>make_build_plotlabserver</code> to trigger a build</p> <p>You can also remove the offending image from your local docker repository with <code>docker image rm &lt;image name&gt;</code> and then invoke <code>make cli</code> to trigger a rebuild.</p> <p>These modules do not change often and only subsequently need to be built once. Any module with a \"build_fast\" target will exhibit this behavior.</p>"},{"location":"system_and_development/caching/","title":"Caching","text":"<p>The ADORe build system contains a number of sources of data caching. Data  caching provides several technical benefits depending on context including  speeding up building and rebuilding, as well as, saving networking resources.  The trade off for this is of course local disk usage. </p> <p>Cache grows over time and can also become stale requiring cleaning and pruning.  The various sources of cache within ADORe will be discussed in the following  sections. Caching also add complexity when fetching packages. Unreliable network with low throughput, high latency or jitter can result in cache corruption or non-deterministic HTTP failures with apt cacher ng. </p>"},{"location":"system_and_development/caching/#apt-cacher-ng","title":"APT Cacher Ng","text":"<p>Apt cacher ng provides caching capability for the APT package manager within  docker containers. It saves network resources by caching/storing debian/ubuntu  system packages so that on subsequent fetching a package is provided via local  cache on disk verses fetching the package from a given remote APT repository.</p>"},{"location":"system_and_development/caching/#cleaning-apt-cacher-ng-cache","title":"Cleaning APT Cacher Ng Cache","text":"<p>To clear/delete or clean the APT cacher ng cache you can use the provided make  target as follows:</p> <pre><code>make clean_apt_cacher_ng_cache\n</code></pre>"},{"location":"system_and_development/caching/#docker-image-caching","title":"Docker Image Caching","text":"<p>Docker image caching is a feature of the ADORe build system and a component of  the make_gadgets submodule locate at:  https://github.com/DLR-TS/make_gadgets</p> <p>Docker image caching supports storing/saving/caching docker images from the  local registry to a local directory containing one tar archive per image. Docker base images can be significantly large and fetching them from the central docker registry can be time consuming and wasteful of network resources, as well as,  potentially running into docker.io free quotas if repeated pulls are done from  the same network. Docker image caching aims to mitigate this by saving base  images locally as archives that can be dynamically loaded as needed instead of  fetching and re-fetching them from the central registry.  </p> <p>This cache is located in the root of the ADORe project in the  '.docker_image_cache' directory'</p>"},{"location":"system_and_development/caching/#cleaning-docker-image-cache","title":"Cleaning Docker Image Cache","text":"<p>Docker image cache can be cleaned by simply deleting the  '.docker_image_cache' directory or calling the provided make target as follows:</p> <pre><code>make clean_docker_image_cache\n</code></pre>"},{"location":"system_and_development/caching/#docker-cache-and-registry","title":"Docker Cache and Registry","text":"<p>Every time docker build or docker compose build are executed on a docker context  the docker daemon generates layer cache. This cache can grow significantly  over time and thus it is important to maintain this cache.</p> <p>The following are sources of docker cache: - Volumes - Networks - Build/Layer cache - Images</p>"},{"location":"system_and_development/caching/#cleaning-docker-cache","title":"Cleaning Docker Cache","text":"<p>The following targets are provided for cleaning various sources of docker cache:</p> <pre><code>docker_orbital_cannon: ## Deletes ALL docker images, volumes, build cache and containers.\ndocker_clean: ## Clean/delete all docker dangling images and build cache\ndocker_delete_all_none_tags: ## Delete all docker orphaned/none tags\ndocker_delete_dangling_images: ## Delete all dangling images/tags\ndocker_delete_all_build_cache: ## Delete all docker builder cache\ndocker_delete_system_prune: ## Prune the docker system\n</code></pre> <p>There is a make target provided from the make_gadgets that will clean all  docker related cache. You can call this target with the following command:</p> <pre><code>make docker_orbital_cannon\n</code></pre> <p>Use this target with caution because it will clean the entire system of  docker cache. Docker cache is a deep topic and it is recommended that you review the official  Docker documentation on the topic at:  https://docs.docker.com/config/pruning/</p>"},{"location":"system_and_development/disable_apt_cacher_ng/","title":"Disable Apt Cacher Ng","text":"<p>This guide will detail how to disable apt cacher ng when it is causing issues.</p>"},{"location":"system_and_development/disable_apt_cacher_ng/#backgound","title":"Backgound","text":"<p>There are some instances where it may be desirable to disable apt cacher ng. Although apt-cacher ng can provide a number of benefits it can also cause build failures on unreliable network connections.</p>"},{"location":"system_and_development/disable_apt_cacher_ng/#apt_cacher_ng_enabled-environmental-variable","title":"<code>APT_CACHER_NG_ENABLED</code> Environmental Variable","text":"<p>To disable apt cacher ng the environmental variable <code>APT_CACHER_NG_ENABLED</code> must be set and equal to <code>false</code>. This can be done several ways. One-off disabling apt cacher:</p> <pre><code>APT_CACHER_NG_ENABLED=false make build\n</code></pre> <p>persistent disabling apt cacher for current interactive session:</p> <pre><code>export APT_CACHER_NG_ENABLED=false \n...\nmake build\n</code></pre>"},{"location":"system_and_development/disable_apt_cacher_ng/#adoreenv","title":"adore.env","text":"<p>There is an environmental file <code>adore.env</code> located in the root of the adore  project.  By default the environmental <code>APT_CACHER_NG_ENABLED</code> is set to <code>true</code> in this file.  To disable apt cacher ng edit this file and replace true with  false. After the file has been edited you can source the environmental file:</p> <pre><code>cd adore\nsource adore.env\n</code></pre> <p>For more information please review the apt-cacher-ng docker documentation:  https://github.com/DLR-TS/apt_cacher_ng_docker</p>"},{"location":"system_and_development/documentation/","title":"Documentation","text":"<p>ADORe provides several sources of Documentation which will be detailed below.</p>"},{"location":"system_and_development/documentation/#landing-page","title":"Landing page","text":"<p>The ADORe landing page is the main github io information web page. Location: https://eclipse.github.io/adore/ \ud83d\udd17</p>"},{"location":"system_and_development/documentation/#mkdocs","title":"mkdocs","text":"<p>ADORe uses mkdocs to compile markdown into a searchable document hub.</p> <p>Location https://eclipse.github.io/adore/mkdocs/ \ud83d\udd17</p>"},{"location":"system_and_development/documentation/#doxygen","title":"Doxygen","text":"<p>ADORe utilized doxygen to auto generate in-source </p> <p>Location https://eclipse.github.io/adore/mkdocs/ \ud83d\udd17</p>"},{"location":"system_and_development/documentation/#gnu-make","title":"GNU Make","text":"<p>Every ADORe module provides a Makefile providing \"documentation-as-code\". To learn what a module offers inspect the available make targets. Every ADORe module also offers a <code>make help</code> target. Call 'make help' to learn what it offers such as with the following example:</p> <pre><code>adore(master) \u2717 (0)&gt; source adore.env\nadore(master) \u2717 (0)&gt; cd adore_if_ros_msg\nadore_if_ros_msg(master) (0)&gt; make help\nUsage: make &lt;target&gt;\n  build                                    Build adore_if_ros_msg\n  clean                                    Clean adore_if_ros_msg build artifacts\n  branch_adore_if_ros_msg                  Returns the current docker safe/sanitized branch for adore_if_ros_msg\n  build_adore_if_ros_msg                   Build adore_if_ros_msg\n  clean_adore_if_ros_msg                   Clean adore_if_ros_msg build artifacts\n  docker_clean                             Clean/delete all docker dangling images and build cache\n  docker_delete_all_build_cache            Delete all docker builder cache\n  docker_delete_all_containers             Stop and delete all docker containers\n  docker_delete_all_none_tags              Delete all docker orphaned/none tags\n  docker_delete_dangling_images            Delete all dangling images/tags\n  docker_orbital_cannon                    Deletes ALL docker images, volumes, build cache and containers. !DangerZone!\n  docker_system_prune                      Prune the docker system\n  get_sanitized_branch_name                Returns a sanitized git branch name with only alphanumeric and ASCII characters permitted as docker tags\n  image_adore_if_ros_msg                   Returns the current docker image name for adore_if_ros_msg\n</code></pre> <p>\u2139\ufe0f INFO: Be sure to source the adore.env file before running any make commands on individual modules. Otherwise you could be greeted with the following error message or similar:</p> <pre><code>INFO: To clone submodules use: 'git submodule update --init --recursive'\nINFO: To specify alternative path for submodules use: SUBMODULES_PATH=\"&lt;path to submodules&gt;\" make build'\nadore_if_ros_msg.mk:21: *** \"ERROR: adore/adore_if_ros_msg/make_gadgets does not exist. Did you clone the submodules?\".  Stop.\n</code></pre>"},{"location":"system_and_development/documentation/#documentation-generation","title":"Documentation Generation","text":"<p>For information on how the sausage (documentation) is made please visit the Documentation Generation \ud83d\udd17 guide.</p>"},{"location":"system_and_development/documentation_docnado/","title":"Documentation","text":"<p>ADORe provides several sources of Documentation which will be detailed below.</p>"},{"location":"system_and_development/documentation_docnado/#landing-page","title":"Landing page","text":"<p>Location: https://eclipse.github.io/adore/w/generated_doxygen_documentation/index.html</p>"},{"location":"system_and_development/documentation_docnado/#docnado","title":"Docnado","text":"<p>ADORe uses Docnado as a documentation layout tool.</p> <p>Location: https://eclipse.github.io/adore/w</p>"},{"location":"system_and_development/documentation_docnado/#doxygen","title":"Doxygen","text":"<p>Location: https://eclipse.github.io/adore/w/generated_doxygen_documentation/index.html</p>"},{"location":"system_and_development/documentation_docnado/#gnu-make","title":"GNU Make","text":"<p>Every ADORe module provides a Makefile providing \"documentation as code\". To learn what a module offers inspect the available make targets. Every ADORe module also offers a <code>make help</code> target. Call 'make help' to learn what it offers such as with the following example:</p> <pre><code>adore(master) \u2717 (0)&gt; source adore.env\nadore(master) \u2717 (0)&gt; cd adore_if_ros_msg\nadore_if_ros_msg(master) (0)&gt; make help\nUsage: make &lt;target&gt;\n  build                                    Build adore_if_ros_msg\n  clean                                    Clean adore_if_ros_msg build artifacts\n  branch_adore_if_ros_msg                  Returns the current docker safe/sanitized branch for adore_if_ros_msg\n  build_adore_if_ros_msg                   Build adore_if_ros_msg\n  clean_adore_if_ros_msg                   Clean adore_if_ros_msg build artifacts\n  docker_clean                             Clean/delete all docker dangling images and build cache\n  docker_delete_all_build_cache            Delete all docker builder cache\n  docker_delete_all_containers             Stop and delete all docker containers\n  docker_delete_all_none_tags              Delete all docker orphaned/none tags\n  docker_delete_dangling_images            Delete all dangling images/tags\n  docker_orbital_cannon                    Deletes ALL docker images, volumes, build cache and containers. !DangerZone!\n  docker_system_prune                      Prune the docker system\n  get_sanitized_branch_name                Returns a sanitized git branch name with only alphanumeric and ASCII characters permitted as docker tags\n  image_adore_if_ros_msg                   Returns the current docker image name for adore_if_ros_msg\n</code></pre> <p>NOTE Be sure to source the adore.env file before running any make commands on individual modules. Otherwise you could be greeted with the following error message or similar:</p> <pre><code>INFO: To clone submodules use: 'git submodule update --init --recursive'\nINFO: To specify alternative path for submodules use: SUBMODULES_PATH=\"&lt;path to submodules&gt;\" make build'\nadore_if_ros_msg.mk:21: *** \"ERROR: adore/adore_if_ros_msg/make_gadgets does not exist. Did you clone the submodules?\".  Stop.\n</code></pre>"},{"location":"system_and_development/documentation_docnado/#documentation-generation","title":"Documentation Generation","text":"<p>For information on how the sausage (documentation) is made please visit the Documentation Generation guide.</p>"},{"location":"system_and_development/documentation_generation/","title":"Documentation Generation","text":"<p>ADORe provides tools to generate all of the documentation detailed in the  documentation readme.</p>"},{"location":"system_and_development/documentation_generation/#usage-generation","title":"Usage: Generation","text":"<ol> <li>cd to the adore documentation directory:     <code>bash     cd adore/documentation</code></li> <li>Call the build target:     <code>bash     make build</code></li> </ol>"},{"location":"system_and_development/documentation_generation/#usage-publication-to-gh-pages","title":"Usage: Publication (to gh-pages)","text":"<p>Assuming you have properly forked the adore repo you can use the Publication target to publish the documents to your personal gh-pages with:</p> <pre><code>make publish\n</code></pre> <p>You have to enable gh-pages on the <code>docs</code> directory in order for the publication to be active. Visit <code>https://github.com/&lt;username&gt;/adore/settings/pages</code> to configure gh-pages. </p>"},{"location":"system_and_development/documentation_generation/#usage-serving-local-copy","title":"Usage: Serving local copy","text":"<p>You can build and serve the documentation locally by running the provide <code>make serve</code> target. Navigate to the documentation directory and run the following:</p> <pre><code>cd adore/documentation\nmake serve\n</code></pre> <p>Once built the documents will be available at http://localhost \ud83d\udd17 </p>"},{"location":"system_and_development/doxygen_documentation/","title":"Doxygen Documentation","text":"<p>Doxygen documentation is provide as part of the ADORe Technical Reference Manual for the ADORe sources which can be found HERE.</p>"},{"location":"system_and_development/howto_document/","title":"Howto document","text":"<ul> <li>The gh-pages documentation is hosted here.</li> <li>The page documentation/Home.md is picked up as an entry point for the gh-pages generator.</li> </ul>"},{"location":"system_and_development/logging/","title":"Logging","text":""},{"location":"system_and_development/logging/#adore-logging","title":"ADORe Logging","text":"<p>Many components within ADORe generate log files of various kinds. This article will highlight interesting log files  and their locations.</p>"},{"location":"system_and_development/logging/#log-directory-log","title":"Log Directory - /.log <p>The general log directory for all ADORe components can be found in the root of the adore repository at:/.log","text":""},{"location":"system_and_development/logging/#ros-logros","title":"ROS - /.log/.ros <p>The most recent ros run will have log files located at:</p> <pre><code>&lt;adore repository root&gt;/.ros/log/latest\n</code></pre>","text":""},{"location":"system_and_development/logging/#plotlab-server-logplotlabserver","title":"Plotlab Server - /.log/plotlabserver","text":""},{"location":"system_and_development/logging/#plotlabmkv","title":"plotlab.mkv","text":"<p>When run in window manger mode or headless mode plotlab will record a video for plotted content. Location: </p> <pre><code>**&lt;adore repository root&gt;/.log/plotlabserver/plotlab.mkv**\n</code></pre> <p>This file is overwritten for each scenario run.</p>"},{"location":"system_and_development/logging/#ffmpeglog","title":"ffmpeg.log","text":"<p>The ffmpeg log contains information on video encoding and length of recorded videos. Location: </p> <pre><code>**&lt;adore repository root&gt;/.log/plotlabserver/plotlab.mkv**\n</code></pre>"},{"location":"system_and_development/static_checking_tools/","title":"Static checking tools","text":""},{"location":"system_and_development/static_checking_tools/#static-checking-tools","title":"Static Checking Tools","text":"<p>There are a number of static checking tools build into ADORe intended to increase code quality.  This article will outline the use of these tools within ADORe.</p>"},{"location":"system_and_development/static_checking_tools/#cppcheck","title":"Cppcheck","text":"<p>Cppcheck is a static analysis tool for C++. More information on Cppcheck can be found at the following link https://cppcheck.sourceforge.io/</p>"},{"location":"system_and_development/static_checking_tools/#basic-usage","title":"Basic Usage","text":"<p>Navigate to a supporting module and run the provided make target:</p> <pre><code>cd libadore\nmake cppcheck\n</code></pre> <p>You can run cppcheck for all supporting components by navigating to the root of the adore repository and running the provided make target:</p> <pre><code>cd adore\nmake cppcheck\n</code></pre>"},{"location":"system_and_development/static_checking_tools/#log-report","title":"Log Report","text":"<p>When you run cppcheck a log report will be generated with the following name: _cppcheck_report.log If you run make lint from the root of the adore repository all lint reports can be found in the .log directory in the root of the repository."},{"location":"system_and_development/static_checking_tools/#cpplint","title":"Cpplint","text":"<p>Cpplint is a command-line tool to check C/C++ files for style issues following Google's C++ style guide. More information on cpplint can be found at https://github.com/cpplint/cpplint</p>"},{"location":"system_and_development/static_checking_tools/#basic-usage_1","title":"Basic Usage","text":"<p>Navigate to a supporting module and run the provided make target:</p> <pre><code>cd libadore\nmake lint\n</code></pre> <p>You can run cpplint for all supporting components by navigating to the root of the adore repository and running the provided make target:</p> <pre><code>cd adore\nmake lint\n</code></pre>"},{"location":"system_and_development/static_checking_tools/#log-report_1","title":"Log Report","text":"<p>When you run cpplint a log report will be generated with the following name: _lint_report.log If you run make lint from the root of the adore repository all lint reports can be found in the .log directory."},{"location":"system_and_development/static_checking_tools/#lizard","title":"Lizard","text":"<p>Lizard is a code complexity static analysis tool. More information on lizard can be found at https://github.com/terryyin/lizard</p>"},{"location":"system_and_development/static_checking_tools/#basic-usage_2","title":"Basic Usage","text":"<p>Navigate to a supporting module and run the provided make target:</p> <pre><code>cd libadore\nmake lizard\n</code></pre> <p>You can run lizard for all supporting components by navigating to the root of the adore repository and running the provided make target:</p> <pre><code>cd adore\nmake lizard\n</code></pre>"},{"location":"system_and_development/static_checking_tools/#log-report_2","title":"Log Report","text":"<p>When you run lizard a log report will be generated with the following name: _lizard_report.xml If you run make lint from the root of the adore repository all lint reports can be found in the .log directory. <p>lizard provides two log files namely, _lizard_report.xml and a human readable _lizard_report.log"},{"location":"system_and_development/static_checking_tools/#final-note","title":"Final note","text":"<p>Some but not all modules within adore provide static checking capabilities. </p>"}]}